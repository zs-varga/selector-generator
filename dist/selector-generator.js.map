{
  "version": 3,
  "sources": ["../src/validators/ElementValidator.js", "../src/services/DOMService.js", "../src/builders/SelectorBuilder.js", "../src/optimizers/BottomUpSelectorOptimizer.js", "../src/optimizers/DebugOptimizer.js", "../src/optimizers/TopDownSelectorOptimizer.js", "../src/config/costs.js", "../src/config/constants.js", "../src/utils/BlacklistMatcher.js", "../src/generators/LocalSelectorGenerator.js", "../src/utils/AttributeCollector.js", "../src/generators/LocalExclusionGenerator.js", "../src/generators/ChildrenSelectorGenerator.js", "../src/generators/ChildrenExclusionGenerator.js", "../src/generators/SiblingSelectorGenerator.js", "../src/generators/ParentSelectorGenerator.js", "../src/SelectorGenerator.js", "../src/index.js"],
  "sourcesContent": ["/**\n * Validates that elements are HTMLElement or SVGElement instances.\n */\nexport class ElementValidator {\n  /**\n   * Checks if an element is valid (HTMLElement or SVGElement).\n   * @param {*} element - The element to validate\n   * @returns {boolean} True if valid, false otherwise\n   */\n  static isValid(element) {\n    return element instanceof HTMLElement || element instanceof SVGElement;\n  }\n\n  /**\n   * Asserts that an element is valid, throws error if not.\n   * @param {*} element - The element to validate\n   * @throws {Error} If element is not HTMLElement or SVGElement\n   */\n  static assertValid(element) {\n    if (!this.isValid(element)) {\n      throw new Error(\"Not an SVG/HTMLElement\");\n    }\n  }\n}\n", "/**\n * Abstraction layer for DOM queries.\n * Allows for easier testing by providing a mockable interface.\n */\nexport class DOMService {\n  /**\n   * Query all elements matching a selector.\n   * @param {string} selector - CSS selector string\n   * @returns {NodeList} List of matching elements\n   */\n  querySelectorAll(selector) {\n    return document.querySelectorAll(selector);\n  }\n\n  /**\n   * Query the first element matching a selector.\n   * @param {string} selector - CSS selector string\n   * @returns {Element|null} First matching element or null\n   */\n  querySelector(selector) {\n    return document.querySelector(selector);\n  }\n}\n", "/**\n * Builds CSS selector strings from selector descriptor sets.\n */\nexport class SelectorBuilder {\n  /**\n   * Builds a selector string from a set of selectors at the same level.\n   * Merges them in proper type order: tag -> id -> class -> attr -> pseudo\n   * @param {Array<SelectorDescriptor>} selectors - Array of selector descriptors at the same level\n   * @returns {string} CSS selector string\n   * @private\n   */\n  #simpleBuild(selectors) {\n    const tagSelectors = selectors.filter((x) => x.type === \"tag\");\n    const idSelectors = selectors.filter((x) => x.type === \"id\");\n    const classSelectors = selectors.filter((x) => x.type === \"class\");\n    const attrSelectors = selectors.filter((x) => x.type === \"attr\");\n    const pseudoSelectors = selectors.filter((x) => x.type === \"pseudo\");\n\n    return (\n      tagSelectors.map((x) => x.selector).join(\"\") +\n      idSelectors.map((x) => x.selector).join(\"\") +\n      classSelectors.map((x) => x.selector).join(\"\") +\n      attrSelectors.map((x) => x.selector).join(\"\") +\n      pseudoSelectors.map((x) => x.selector).join(\"\")\n    );\n  }\n\n  /**\n   * Builds a complete CSS selector string from a set of selector descriptors.\n   * @param {Array<SelectorDescriptor>} selectorSet - Array of selector descriptors\n   * @returns {string} CSS selector string\n   */\n  build(selectorSet) {\n    const tagSelectors = selectorSet.filter(\n      (x) => x.type === \"tag\" && x.level <= 0\n    );\n    const idSelectors = selectorSet.filter(\n      (x) => x.type === \"id\" && x.level <= 0\n    );\n    const classSelectors = selectorSet.filter(\n      (x) => x.type === \"class\" && x.level <= 0\n    );\n    const attrSelectors = selectorSet.filter(\n      (x) => x.type === \"attr\" && x.level <= 0\n    );\n    const pseudoSelectors = selectorSet.filter(\n      (x) => x.type === \"pseudo\" && x.level <= 0\n    );\n    const parentSelectors = selectorSet.filter((x) => x.level > 0);\n\n    let selector =\n      tagSelectors.map((x) => x.selector).join(\"\") +\n      idSelectors.map((x) => x.selector).join(\"\") +\n      classSelectors.map((x) => x.selector).join(\"\") +\n      attrSelectors.map((x) => x.selector).join(\"\") +\n      pseudoSelectors.map((x) => x.selector).join(\"\");\n\n    if (selector === \"\") {\n      selector = \"*\";\n    }\n    \n    if (parentSelectors.length > 0) {\n      // Group parent selectors by level\n      const levelMap = new Map();\n      for (const ps of parentSelectors) {\n        if (!levelMap.has(ps.level)) {\n          levelMap.set(ps.level, []);\n        }\n        levelMap.get(ps.level).push(ps);\n      }\n\n      // Sort levels in ascending order\n      const levels = Array.from(levelMap.keys()).sort((a, b) => a - b);\n\n      let prevLevel = 0;\n      for (const level of levels) {\n        // Use simpleBuild to merge selectors at the same level in proper order\n        const levelSelector = this.#simpleBuild(levelMap.get(level));\n\n        // Add appropriate combinator based on level difference\n        if (level === prevLevel + 1) {\n          selector = levelSelector + \" > \" + selector;\n        } else {\n          selector = levelSelector + \" \" + selector;\n        }\n\n        prevLevel = level;\n      }\n    }\n\n    return selector;\n  }\n}\n", "/**\n * Optimizes selector sets using a bottom-up greedy approach.\n * Starts with empty set and adds selectors that provide the most improvement.\n */\nexport class BottomUpSelectorOptimizer {\n  /**\n   * Creates a BottomUpSelectorOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Calculates the value (specificity score) of a selector set.\n   * Returns the count of elements matching the selector, or Infinity if invalid.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {number} Number of matching elements, or Infinity if invalid\n   */\n  getValue(elements, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return Infinity;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    const count = results.length;\n\n    if (count === 0) {\n      console.error(\"Empty selector: \", selector, selectorSet);\n      return Infinity;\n    }\n\n    const resultsArray = Array.from(results);\n\n    // Check if all target elements are in results\n    for (const element of elements) {\n      if (!resultsArray.includes(element)) {\n        console.error(\n          \"Element is missing from selector results: \",\n          selector,\n          selectorSet\n        );\n        return Infinity;\n      }\n    }\n\n    return count;\n  }\n\n  /**\n   * Finds the best selector set that identifies all target elements.\n   * Uses a greedy optimization algorithm with decreasing thresholds.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectors - Array of all available selector descriptors\n   * @returns {Array<SelectorDescriptor>} Optimized selector set\n   */\n  findBest(elements, selectors) {\n    selectors.sort((a, b) => a.cost - b.cost);\n\n    let bestSelectorSet = [];\n    let bestValue = Infinity;\n    const targetCount = elements.length;\n\n    for (let threshold = 16; threshold >= 1; threshold = threshold / 2) {\n      let improving = true;\n      while (improving) {\n        improving = false;\n\n        let localBestSelectorSet = [...bestSelectorSet];\n        let localBestValue = bestValue;\n        let trialSelectorSet = [...bestSelectorSet];\n        let trialValue = Infinity;\n\n        for (const currentSelector of selectors) {\n          if (trialSelectorSet.includes(currentSelector)) {\n            continue;\n          }\n\n          // Skip parent selectors if there is no other selectors in the set yet\n          if (bestSelectorSet.length === 0 && currentSelector.level > 0) {\n            continue;\n          }\n\n          trialSelectorSet = [...bestSelectorSet, currentSelector];\n          trialValue = this.getValue(elements, trialSelectorSet);\n\n          if (localBestValue - trialValue >= threshold) {\n            localBestValue = trialValue;\n            localBestSelectorSet = [...trialSelectorSet];\n          }\n\n          // we found a perfect match\n          if (trialValue === targetCount) {\n            break;\n          }\n        }\n\n        if (bestValue - localBestValue > 0) {\n          bestSelectorSet = [...localBestSelectorSet];\n          bestValue = localBestValue;\n          if (bestValue === targetCount) {\n            return bestSelectorSet;\n          }\n          improving = true;\n        }\n\n        if (localBestValue === targetCount) {\n          break;\n        }\n      }\n    }\n\n    return bestSelectorSet;\n  }\n}\n", "/**\n * Debug optimizer for finding the smallest subset of selectors that does not match the target element.\n * Used when a selectorSet unexpectedly fails to match - helps identify the problematic selector(s).\n */\nexport class DebugOptimizer {\n  /**\n   * Creates a DebugOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Checks if a selector set matches the target element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {boolean} True if element is matched by the selector set\n   */\n  matches(element, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return false;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    return Array.from(results).includes(element);\n  }\n\n  /**\n   * Finds the minimal subset of selectors that does NOT match the target element.\n   * Single pass: removes each selector if the set still doesn't match without it.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectors - Array of selector descriptors (must not match element)\n   * @returns {Array<SelectorDescriptor>} Minimal non-matching subset\n   */\n  findMinimalNonMatchingSet(element, selectors) {\n    let result = [...selectors];\n\n    // Single pass: try removing each selector\n    for (let i = result.length - 1; i >= 0; i--) {\n      // Try the set without this selector\n      const trialSet = result.filter((_, index) => index !== i);\n\n      // If it still doesn't match without this selector, it's redundant - remove it\n      if (!this.matches(element, trialSet)) {\n        result = trialSet;\n      }\n    }\n\n    return result;\n  }\n}\n", "import { DebugOptimizer } from './DebugOptimizer.js';\n\n/**\n * Optimizes selector sets using a top-down approach.\n * Starts with all selectors and removes unnecessary ones while maintaining uniqueness.\n */\nexport class TopDownSelectorOptimizer {\n  /**\n   * Creates a TopDownSelectorOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n    this.debugOptimizer = new DebugOptimizer(domService, selectorBuilder);\n  }\n\n  /**\n   * Calculates the value (specificity score) of a selector set.\n   * Considers both the count of elements matching the selector and the sum of costs.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {{count: number, quality: number}} Object with count and quality, or null if invalid\n   */\n  getValue(elements, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return null;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    const count = results.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const resultsArray = Array.from(results);\n\n    // Check if all target elements are in results\n    for (const element of elements) {\n      if (!resultsArray.includes(element)) {\n        console.error(\n          \"Element is missing from selector results: \",\n          selector,\n          selectorSet\n        );\n        return null;\n      }\n    }\n\n    // Calculate sum of costs in the selector set\n    // Lower cost sum = better quality\n    const cost = selectorSet.reduce((sum, descriptor) => sum + descriptor.cost, 0);\n\n    // Return object with both count and quality\n    return { count, cost };\n  }\n\n  /**\n   * Finds the best selector set using top-down optimization with local best solution.\n   * Starts with all selectors and iteratively removes selectors (sorted by cost),\n   * stopping at the first removal that maintains uniqueness (count = elements.length).\n   * @param {Array<HTMLElement|SVGElement>} targetElements - The target elements\n   * @param {Array<SelectorDescriptor>} selectors - Array of all available selector descriptors\n   * @returns {Array<SelectorDescriptor>} Optimized selector set\n   */\n  findBest(targetElements, selectors) {\n    const targetCount = targetElements.length;\n\n    // Start with all selectors\n    let currentSet = [...selectors];\n    let currentValue = this.getValue(targetElements, currentSet);\n    const startingCount = currentValue ? currentValue.count : 0;\n\n    // If not unique even with all selectors, use debug optimizer to find minimal non-matching set\n    // Only if we are finding a selector for a single element\n    if (!currentValue || currentValue.count !== startingCount) {\n      console.warn(\n        `Top-down optimizer: All selectors combined do not produce a selector matching exactly ${targetCount} element(s). Finding minimal non-matching subset for debugging.`\n      );\n      const minimalNonMatching = this.debugOptimizer.findMinimalNonMatchingSet(targetElements[0], currentSet);\n      console.log(\n        \"The problematic selector is this:\",\n        minimalNonMatching,\n        this.selectorBuilder.build(minimalNonMatching)\n      );\n      return currentSet;\n    }\n\n    // Sort selectors by cost (descending) - highest cost value first (worst quality)\n    // This way we try to remove the worst quality selectors first\n    const sortedSelectors = [...currentSet].sort((a, b) => b.cost - a.cost);\n\n    // Iteratively try removing selectors in cost order\n    let improved = true;\n    while (improved && currentSet.length > 1) {\n      improved = false;\n\n      // Try removing selectors in cost order, stop at first success\n      for (const selectorToRemove of sortedSelectors) {\n        // Skip if selector is no longer in current set (already removed)\n        if (!currentSet.includes(selectorToRemove)) {\n          continue;\n        }\n\n        // Skip removal of level=0, type=tag selectors (base element selector)\n        if (selectorToRemove.level === 0 && selectorToRemove.type === 'tag') {\n          continue;\n        }\n\n        const trialSet = currentSet.filter(s => s !== selectorToRemove);\n        const trialValue = this.getValue(targetElements, trialSet);\n\n        // Check if elements still match exactly (count = startingCount)\n        if (trialValue && trialValue.count === startingCount) {\n          // Still matching after removal, commit this change and continue\n          currentSet = trialSet;\n          currentValue = trialValue;\n          improved = true;\n          break; // Stop at first improvement and try again\n        }\n      }\n    }\n\n    return currentSet;\n  }\n}\n", "/**\n * Cost constants for selector generation.\n * Lower values indicate higher quality in selector selection.\n */\n\n/*\n\nlocal: id, tag, class, attr\nstructural: parent, child, sibling\nmodifier: not, has\n\n*/\n\nexport const COST_ID = 0;\nexport const COST_CLASS = 1;\nexport const COST_TAG = 2;\nexport const COST_ATTR = 3;\n\nexport const COST_PARENT = 10;\nexport const COST_SIBLING = 100;\nexport const COST_CHILDREN = 100;\nexport const COST_DISTANCE = 1;\n\nexport const COST_IS_HAS = 5; // contains :is(), :has()\nexport const COST_NOT = 10; // contains :not()\n", "/**\n * Blacklist patterns for filtering IDs, classes, and attributes.\n * Supports wildcards: * matches any sequence of characters.\n * Examples:\n *   \"*-ng-*\" matches \"app-ng-content\", \"ng-scope\", etc.\n *   \"temp-*\" matches \"temp-123\", \"temp-xyz\", etc.\n *   \"*generated*\" matches \"auto-generated-id\", \"generated\", etc.\n */\nexport const BLACKLIST_IDS = [\n  \"*lottie*\",\n  \"selector-generator\"\n];\n\nexport const BLACKLIST_CLASSES = [\n  \"*-ng-*\", // Angular generated classes\n  \"ng-*\", // Angular directives\n  \"*tw-*\",\n  \"*[*px]*\",\n];\n\nexport const BLACKLIST_ATTRIBUTES = [\n  \"id\",\n  \"style\",\n  \"*-ng-*\", // Angular generated classes\n  \"ng-*\", // Angular directives\n  \"*tw-*\",\n  \"xmlns*\",\n];\n", "/**\n * Utility for matching strings against wildcard patterns.\n */\nexport class BlacklistMatcher {\n  /**\n   * Converts a wildcard pattern to a regular expression.\n   * @param {string} pattern - Pattern with * wildcards\n   * @returns {RegExp} Regular expression\n   * @private\n   */\n  static #patternToRegex(pattern) {\n    // Escape special regex characters except *\n    const escaped = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    // Replace * with .*\n    const regexPattern = '^' + escaped.replace(/\\*/g, '.*') + '$';\n    return new RegExp(regexPattern);\n  }\n\n  /**\n   * Checks if a value matches any pattern in the blacklist.\n   * @param {string} value - Value to check\n   * @param {Array<string>} patterns - Array of wildcard patterns\n   * @returns {boolean} True if value matches any pattern\n   */\n  static matches(value, patterns) {\n    if (!value || !patterns || patterns.length === 0) {\n      return false;\n    }\n\n    for (const pattern of patterns) {\n      const regex = this.#patternToRegex(pattern);\n      if (regex.test(value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Filters an array of values, removing those that match blacklist patterns.\n   * @param {Array<string>} values - Values to filter\n   * @param {Array<string>} patterns - Array of wildcard patterns\n   * @returns {Array<string>} Filtered values\n   */\n  static filter(values, patterns) {\n    if (!values || values.length === 0) {\n      return values;\n    }\n\n    if (!patterns || patterns.length === 0) {\n      return values;\n    }\n\n    return values.filter(value => !this.matches(value, patterns));\n  }\n}", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_ID,\n  COST_TAG,\n  COST_CLASS,\n  COST_ATTR,\n} from \"../config/costs.js\";\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from \"../config/constants.js\";\nimport { BlacklistMatcher } from \"../utils/BlacklistMatcher.js\";\n\n/**\n * Generates selectors based on an element's own properties (ID, tag, classes, attributes).\n */\nexport class LocalSelectorGenerator {\n  /**\n   * Generates local selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Get selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      // Add ID selector if not blacklisted\n      if (\n        element.id !== \"\" &&\n        !BlacklistMatcher.matches(element.id, BLACKLIST_IDS)\n      ) {\n        sels.push({\n          cost: COST_ID,\n          level: 0,\n          type: \"id\",\n          selector: \"#\" + CSS.escape(element.id),\n        });\n      }\n\n      // Always add tag selector\n      sels.push({\n        cost: COST_TAG,\n        level: 0,\n        type: \"tag\",\n        selector: element.localName,\n      });\n\n      for (\n        let i = 0, attributes = element.attributes;\n        i < attributes.length;\n        i++\n      ) {\n        const name = attributes.item(i).name;\n\n        if (name === \"class\") {\n          element.classList.forEach((currentClass) => {\n            // Skip blacklisted classes\n            if (!BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)) {\n              sels.push({\n                cost: COST_CLASS,\n                level: 0,\n                type: \"class\",\n                selector: \".\" + CSS.escape(currentClass),\n              });\n            }\n          });\n          continue;\n        }\n\n        // Skip blacklisted attributes\n        if (!BlacklistMatcher.matches(name, BLACKLIST_ATTRIBUTES)) {\n          sels.push({\n            cost: COST_ATTR,\n            level: 0,\n            type: \"attr\",\n            selector: \"[\" + CSS.escape(name) + \"]\",\n          });\n        }\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(\n          (d) =>\n            d.level === descriptor.level &&\n            d.type === descriptor.type &&\n            d.selector === descriptor.selector\n        )\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { BlacklistMatcher } from './BlacklistMatcher.js';\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from '../config/constants.js';\n\n/**\n * Utility class for collecting and analyzing attributes from elements.\n */\nexport class AttributeCollector {\n  /**\n   * Creates an AttributeCollector instance.\n   * @param {HTMLElement|SVGElement} targetElement - The target element to compare against\n   */\n  constructor(targetElement) {\n    this.targetElement = targetElement;\n  }\n\n  /**\n   * Collects extra IDs from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped ID values\n   */\n  collectExtraIds(elements) {\n    const extraIds = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      const id = currentElement.getAttribute(\"id\");\n      if (id !== null && !BlacklistMatcher.matches(id, BLACKLIST_IDS)) {\n        extraIds.push(CSS.escape(id));\n      }\n    }\n\n    return extraIds;\n  }\n\n  /**\n   * Collects extra classes from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped class names\n   */\n  collectExtraClasses(elements) {\n    const extraClasses = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      currentElement.classList.forEach((currentClass) => {\n        if (\n          !this.targetElement.classList.contains(currentClass) &&\n          !extraClasses.includes(currentClass) &&\n          !BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)\n        ) {\n          extraClasses.push(CSS.escape(currentClass));\n        }\n      });\n    }\n\n    return extraClasses;\n  }\n\n  /**\n   * Collects extra attributes from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped attribute names\n   */\n  collectExtraAttributes(elements) {\n    const extraAttr = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      const attributes = currentElement.attributes;\n      for (let j = 0; j < attributes.length; j++) {\n        const currentAttr = attributes.item(j);\n        if (\n          !this.targetElement.hasAttribute(currentAttr.name) &&\n          !extraAttr.includes(currentAttr.name) &&\n          !BlacklistMatcher.matches(currentAttr.name, BLACKLIST_ATTRIBUTES)\n        ) {\n          extraAttr.push(CSS.escape(currentAttr.name));\n        }\n      }\n    }\n\n    return extraAttr;\n  }\n\n  /**\n   * Collects all extra attributes (IDs, classes, attributes) at once.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Object} Object with extraIds, extraClasses, extraAttributes arrays\n   */\n  collectAll(elements) {\n    return {\n      extraIds: this.collectExtraIds(elements),\n      extraClasses: this.collectExtraClasses(elements),\n      extraAttributes: this.collectExtraAttributes(elements),\n    };\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport { AttributeCollector } from \"../utils/AttributeCollector.js\";\nimport {\n  COST_NOT,\n  COST_ATTR,\n  COST_CLASS,\n  COST_ID,\n} from \"../config/costs.js\";\n\n/**\n * Generates :not() pseudo-selectors to exclude similar elements.\n */\nexport class LocalExclusionGenerator {\n  /**\n   * Creates a LocalExclusionGenerator instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, localGenerator, selectorBuilder) {\n    this.domService = domService;\n    this.localGenerator = localGenerator;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Generates exclusion selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate exclusion selectors for each element\n    const elementExclusions = elements.map(element => {\n      const localSelectors = this.localGenerator.generate([element]);\n      const baseSelector = this.selectorBuilder.build(localSelectors);\n      const matchedElements = this.domService.querySelectorAll(baseSelector);\n\n      const exclSelectors = [];\n      const collector = new AttributeCollector(element);\n\n      const { extraIds, extraClasses, extraAttributes } =\n        collector.collectAll(matchedElements);\n\n      for (let i = 0; i < extraIds.length; i++) {\n        exclSelectors.push({\n          cost: COST_NOT + COST_ID,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(#\" + extraIds[i] + \")\",\n        });\n      }\n\n      for (let i = 0; i < extraClasses.length; i++) {\n        exclSelectors.push({\n          cost: COST_NOT + COST_CLASS,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(.\" + extraClasses[i] + \")\",\n        });\n      }\n\n      for (let i = 0; i < extraAttributes.length; i++) {\n        exclSelectors.push({\n          cost: COST_NOT + COST_ATTR,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not([\" + extraAttributes[i] + \"])\",\n        });\n      }\n\n      return exclSelectors;\n    });\n\n    // Find common selectors across all elements\n    if (elementExclusions.length === 0) return selectors;\n\n    const firstSet = elementExclusions[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementExclusions.every(set =>\n        set.some(\n          (d) =>\n            d.level === descriptor.level &&\n            d.type === descriptor.type &&\n            d.selector === descriptor.selector\n        )\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_DISTANCE,\n  COST_CHILDREN,\n  COST_IS_HAS,\n  COST_NOT,\n} from \"../config/costs.js\";\n\n/**\n * Generates selectors based on an element's children.\n */\nexport class ChildrenSelectorGenerator {\n  /**\n   * Creates a ChildrenSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   */\n  constructor(localGenerator) {\n    this.localGenerator = localGenerator;\n  }\n\n  /**\n   * Recursively processes children and their descendants.\n   * @private\n   * @param {HTMLElement|SVGElement} element - Current element being processed\n   * @param {number} depth - Current depth\n   * @param {Array<SelectorDescriptor>} selectors - Accumulator for selector descriptors\n   */\n  #processChildren(element, depth, selectors) {\n    const children = element.children;\n    const depthSelector = \">*\".repeat(depth);\n\n    if (children.length === 0) {\n      // The element contains only text\n      // :has cannot be nested, so we can't do selectors for deeper levels like \":has(>*:not(:has(>*)))\"\n      if (element.childNodes.length > 0 && depth === 0) {\n        selectors.push({\n          cost:\n            depth * COST_DISTANCE + COST_NOT + COST_IS_HAS + COST_CHILDREN,\n          level: 0,\n          type: \"pseudo\",\n          selector: `:not(:has(>*))`,\n        });\n        return selectors;\n      }\n\n      // The element contains nothing OR contains :before OR :after pseudo elements\n      if (element.childNodes.length === 0) {\n        selectors.push({\n          cost: depth * COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n          level: 0,\n          type: \"pseudo\",\n          selector: depth > 0 ? `:has(${depthSelector}:empty)` : `:empty`,\n        });\n        if (depth > 0) {\n          selectors.push({\n            cost: COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n            level: 0,\n            type: \"pseudo\",\n            selector: `:has(:empty)`,\n          });\n        }\n      }\n      return selectors;\n    }\n\n    // has n direct children\n    selectors.push({\n      cost: depth * COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n      level: 0,\n      type: \"pseudo\",\n      selector:\n        depth > 0\n          ? `:has(${depthSelector}>*:nth-child(${children.length}):last-child)`\n          : `:has(:nth-child(${children.length}):last-child)`,\n    });\n    if (depth > 0) {\n      selectors.push({\n        cost: COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n        level: 0,\n        type: \"pseudo\",\n        selector: `:has(* :nth-child(${children.length}):last-child)`,\n      });\n    }\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      const localSelectors = this.localGenerator.generate([child]);\n      for (const childrenLocalSelector of localSelectors) {\n        selectors.push({\n          cost:\n            depth * COST_DISTANCE +\n            COST_IS_HAS +\n            COST_CHILDREN +\n            childrenLocalSelector.cost,\n          level: 0,\n          type: \"pseudo\",\n          selector:\n            depth > 0\n              ? `:has(${depthSelector}>${childrenLocalSelector.selector})`\n              : `:has(>${childrenLocalSelector.selector})`,\n        });\n\n        if (depth > 0) {\n          selectors.push({\n            cost:\n              COST_DISTANCE +\n              COST_IS_HAS +\n              COST_CHILDREN +\n              childrenLocalSelector.cost,\n            level: 0,\n            type: \"pseudo\",\n            selector: `:has(* ${childrenLocalSelector.selector})`,\n          });\n        }\n      }\n\n      // Recursively process descendants (go deeper, more negative level)\n      this.#processChildren(child, depth + 1, selectors);\n    }\n  }\n\n  /**\n   * Generates children selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate children selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n      this.#processChildren(element, 0, sels);\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(\n          (d) =>\n            d.level === descriptor.level &&\n            d.type === descriptor.type &&\n            d.selector === descriptor.selector\n        )\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_ATTR,\n  COST_CHILDREN,\n  COST_CLASS,\n  COST_IS_HAS,\n  COST_ID,\n  COST_NOT,\n} from \"../config/costs.js\";\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from \"../config/constants.js\";\nimport { BlacklistMatcher } from \"../utils/BlacklistMatcher.js\";\n\n/**\n * Generates :not(:has()) pseudo-selectors to exclude elements based on other elements children\n * If elements differ only by their children, we can select them by the selectors generates by this class\n */\nexport class ChildrenExclusionGenerator {\n  /**\n   * Creates a ChildrenExclusionGenerator instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, localGenerator, selectorBuilder) {\n    this.domService = domService;\n    this.localGenerator = localGenerator;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Generates children exclusion selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate children exclusion selectors for each element\n    const elementSelectors = elements.map((element) => {\n      const sels = [];\n\n      const elementSelector = this.localGenerator.generate([element]);\n      const childrenSelector =\n        this.selectorBuilder.build(elementSelector) + \" *\";\n      const allChildren = this.domService.querySelectorAll(childrenSelector);\n\n      const extraClasses = [];\n      const extraAttr = [];\n\n      for (let i = 0; i < allChildren.length; i++) {\n        const currentChild = allChildren[i];\n\n        // Skip children that belong to the element itself\n        if (element.contains(currentChild)) {\n          continue;\n        }\n\n        // Collect extra id (skip if blacklisted)\n        const id = currentChild.getAttribute(\"id\");\n        if (id !== null && !BlacklistMatcher.matches(id, BLACKLIST_IDS)) {\n          sels.push({\n            cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_ID,\n            level: 0,\n            type: \"pseudo\",\n            selector: \":not(:has(#\" + CSS.escape(id) + \"))\",\n          });\n        }\n\n        // Collect extra classes (skip if blacklisted)\n        currentChild.classList.forEach((currentClass) => {\n          if (\n            !element.querySelector(\".\" + CSS.escape(currentClass)) &&\n            !extraClasses.includes(currentClass) &&\n            !BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)\n          ) {\n            extraClasses.push(CSS.escape(currentClass));\n          }\n        });\n\n        // Collect extra attributes (skip if blacklisted)\n        const attributes = currentChild.attributes;\n        for (let j = 0; j < attributes.length; j++) {\n          const currentAttr = attributes.item(j);\n          if (\n            !element.querySelector(\"[\" + CSS.escape(currentAttr.name) + \"]\") &&\n            !extraAttr.includes(currentAttr.name) &&\n            !BlacklistMatcher.matches(currentAttr.name, BLACKLIST_ATTRIBUTES)\n          ) {\n            extraAttr.push(CSS.escape(currentAttr.name));\n          }\n        }\n      }\n\n      for (let i = 0; i < extraClasses.length; i++) {\n        sels.push({\n          cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_CLASS,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(:has(.\" + extraClasses[i] + \"))\",\n        });\n      }\n\n      for (let i = 0; i < extraAttr.length; i++) {\n        sels.push({\n          cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_ATTR,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(:has([\" + extraAttr[i] + \"]))\",\n        });\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every((set) =>\n        set.some(\n          (d) =>\n            d.level === descriptor.level &&\n            d.type === descriptor.type &&\n            d.selector === descriptor.selector\n        )\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_DISTANCE,\n  COST_IS_HAS,\n  COST_SIBLING,\n} from \"../config/costs.js\";\n\n/**\n * Generates selectors based on sibling relationships.\n */\nexport class SiblingSelectorGenerator {\n  /**\n   * Creates a SiblingSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   */\n  constructor(localGenerator) {\n    this.localGenerator = localGenerator;\n  }\n\n  /**\n   * Generates sibling selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate sibling selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      let prevSibling = element.previousElementSibling;\n      const prevSiblingCount =\n        prevSibling !== null\n          ? Array.from(element.parentElement.children).indexOf(element)\n          : 0;\n\n      let nextSibling = element.nextElementSibling;\n      const nextSiblingCount =\n        nextSibling !== null\n          ? Array.from(element.parentElement.children).length -\n            Array.from(element.parentElement.children).indexOf(element)\n          : 0;\n\n      if (prevSibling === null) {\n        // there is no previous sibling\n        sels.push({\n          cost: (nextSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":first-child\",\n        });\n      } else {\n        // there are previous siblings\n        sels.push({\n          cost: (prevSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":nth-child(\" + (prevSiblingCount + 1) + \")\",\n        });\n      }\n\n      if (nextSibling === null) {\n        // there is no next sibling\n        sels.push({\n          cost: (prevSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":last-child\",\n        });\n      } else {\n        // there are next siblings, so we can use nth-last-child\n        // however, we will only use this if there are prev siblings too\n        // if there are not, nth-child is better\n        if (prevSiblingCount > 0) {\n          sels.push({\n            cost: (nextSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n            level: 0,\n            type: \"pseudo\",\n            selector: \":nth-last-child(\" + nextSiblingCount + \")\",\n          });\n        }\n      }\n\n      if (prevSibling === null && nextSibling === null) {\n        sels.push({\n          cost: COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":only-child\",\n        });\n      }\n\n      while (prevSibling) {\n        if (prevSibling.nodeType === Node.COMMENT_NODE) {\n          prevSibling = prevSibling.previousElementSibling;\n          continue;\n        }\n        if (prevSibling.nodeType === Node.TEXT_NODE) {\n          prevSibling = prevSibling.previousElementSibling;\n          continue;\n        }\n\n        const localSelectors = this.localGenerator.generate([prevSibling]);\n        for (const currentSelector of localSelectors) {\n          if (\n            !sels.some(\n              (s) => s.selector === \":is(\" + currentSelector.selector + \" ~ *)\"\n            )\n          ) {\n            sels.push({\n              cost: COST_SIBLING + COST_IS_HAS + currentSelector.cost,\n              level: 0,\n              type: \"pseudo\",\n              selector: \":is(\" + currentSelector.selector + \" ~ *)\",\n            });\n          }\n        }\n        prevSibling = prevSibling.previousElementSibling;\n      }\n\n      while (nextSibling) {\n        if (nextSibling.nodeType === Node.COMMENT_NODE) {\n          nextSibling = nextSibling.nextElementSibling;\n          continue;\n        }\n        if (nextSibling.nodeType === Node.TEXT_NODE) {\n          nextSibling = nextSibling.nextElementSibling;\n          continue;\n        }\n\n        const localSelectors = this.localGenerator.generate([nextSibling]);\n        for (const currentSelector of localSelectors) {\n          if (\n            !sels.some(\n              (s) => s.selector === \":has(~ \" + currentSelector.selector + \")\"\n            )\n          ) {\n            sels.push({\n              cost: COST_SIBLING + COST_IS_HAS + currentSelector.cost,\n              level: 0,\n              type: \"pseudo\",\n              selector: \":has(~ \" + currentSelector.selector + \")\",\n            });\n          }\n        }\n        nextSibling = nextSibling.nextElementSibling;\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(\n          (d) =>\n            d.level === descriptor.level &&\n            d.type === descriptor.type &&\n            d.selector === descriptor.selector\n        )\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport { COST_DISTANCE, COST_PARENT } from \"../config/costs.js\";\n\n/**\n * Generates selectors based on parent elements.\n */\nexport class ParentSelectorGenerator {\n  /**\n   * Creates a ParentSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {LocalExclusionGenerator} exclusionGenerator - Generator for exclusion selectors\n   * @param {SiblingSelectorGenerator} siblingGenerator - Generator for sibling selectors\n   */\n  constructor(localGenerator, exclusionGenerator, siblingGenerator) {\n    this.localGenerator = localGenerator;\n    this.exclusionGenerator = exclusionGenerator;\n    this.siblingGenerator = siblingGenerator;\n  }\n\n  /**\n   * Generates parent selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate parent selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      let currentParent = element.parentElement;\n      let level = 1;\n\n      while (currentParent) {\n        const localSelectors = this.localGenerator.generate([currentParent]);\n        for (const currentSelector of localSelectors) {\n          sels.push({\n            cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n            level: level,\n            type: currentSelector.type,\n            selector: currentSelector.selector,\n          });\n        }\n\n        const localExclSelectors =\n          this.exclusionGenerator.generate([currentParent]);\n        for (const currentSelector of localExclSelectors) {\n          sels.push({\n            cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n            level: level,\n            type: currentSelector.type,\n            selector: currentSelector.selector,\n          });\n        }\n\n        const siblingSelectors = this.siblingGenerator.generate([currentParent]);\n        for (const currentSelector of siblingSelectors) {\n          sels.push({\n            cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n            level: level,\n            type: currentSelector.type,\n            selector: currentSelector.selector,\n          });\n        }\n\n        currentParent = currentParent.parentElement;\n        level = level + 1;\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(\n          (d) =>\n            d.level === descriptor.level &&\n            d.type === descriptor.type &&\n            d.selector === descriptor.selector\n        )\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from './validators/ElementValidator.js';\nimport { DOMService } from './services/DOMService.js';\nimport { SelectorBuilder } from './builders/SelectorBuilder.js';\nimport { BottomUpSelectorOptimizer } from './optimizers/BottomUpSelectorOptimizer.js';\nimport { TopDownSelectorOptimizer } from './optimizers/TopDownSelectorOptimizer.js';\nimport { LocalSelectorGenerator } from './generators/LocalSelectorGenerator.js';\nimport { LocalExclusionGenerator } from './generators/LocalExclusionGenerator.js';\nimport { ChildrenSelectorGenerator } from './generators/ChildrenSelectorGenerator.js';\nimport { ChildrenExclusionGenerator } from './generators/ChildrenExclusionGenerator.js';\nimport { SiblingSelectorGenerator } from './generators/SiblingSelectorGenerator.js';\nimport { ParentSelectorGenerator } from './generators/ParentSelectorGenerator.js';\n\n/**\n * Main class for generating optimal CSS selectors for DOM elements.\n */\nexport class SelectorGenerator {\n  constructor() {\n    // Initialize services\n    this.domService = new DOMService();\n    this.selectorBuilder = new SelectorBuilder();\n    this.bottomUpOptimizer = new BottomUpSelectorOptimizer(this.domService, this.selectorBuilder);\n    this.topDownOptimizer = new TopDownSelectorOptimizer(this.domService, this.selectorBuilder);\n\n    // Initialize generators\n    this.localGenerator = new LocalSelectorGenerator();\n    this.exclusionGenerator = new LocalExclusionGenerator(\n      this.domService,\n      this.localGenerator,\n      this.selectorBuilder\n    );\n    this.childrenGenerator = new ChildrenSelectorGenerator(this.localGenerator);\n    this.childrenExclusionGenerator = new ChildrenExclusionGenerator(\n      this.domService,\n      this.localGenerator,\n      this.selectorBuilder\n    );\n    this.siblingGenerator = new SiblingSelectorGenerator(this.localGenerator);\n    this.parentGenerator = new ParentSelectorGenerator(\n      this.localGenerator,\n      this.exclusionGenerator,\n      this.siblingGenerator\n    );\n  }\n\n  /**\n   * Generates an optimal CSS selector for the given element(s).\n   * For a single element, generates a unique selector matching only that element.\n   * For multiple elements, generates a selector matching all of them (and only them).\n   * Elements can be at any level in the DOM tree as long as they share a common ancestor.\n   * @param {HTMLElement|SVGElement|Array<HTMLElement|SVGElement>} elements - The target element(s)\n   * @returns {string} CSS selector string that uniquely identifies the element(s)\n   * @throws {Error} If elements are invalid or don't share a common ancestor\n   */\n  getSelector(elements) {\n    // Handle both single element and array of elements\n    const normalizedElements = Array.isArray(elements) ? elements : [elements];\n\n    // Validate all elements\n    for (const element of normalizedElements) {\n      ElementValidator.assertValid(element);\n    }\n\n    // For multiple elements, verify they share a common ancestor\n    if (normalizedElements.length > 1) {\n      // Check that all elements are connected in the same document\n      const firstDoc = normalizedElements[0].ownerDocument;\n      for (let i = 1; i < normalizedElements.length; i++) {\n        if (normalizedElements[i].ownerDocument !== firstDoc) {\n          throw new Error(\n            `All elements must belong to the same document for multi-element selector generation`\n          );\n        }\n      }\n    }\n\n    let selectors = [];\n\n    selectors = selectors.concat(this.localGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.exclusionGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.childrenGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.siblingGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.parentGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.childrenExclusionGenerator.generate(normalizedElements));\n\n    /*\n    // Try bottom-up optimization first (fast, works for most cases)\n    let bestSelectorSet = this.bottomUpOptimizer.findBest(normalizedElements, selectors);\n    let value = this.bottomUpOptimizer.getValue(normalizedElements, bestSelectorSet);\n\n    // If bottom-up didn't find a unique selector, try top-down\n    if (value !== normalizedElements.length) {\n      bestSelectorSet = this.topDownOptimizer.findBest(normalizedElements, selectors);\n    }\n    */\n\n    let bestSelectorSet = this.topDownOptimizer.findBest(normalizedElements, selectors);\n\n    const selector = this.selectorBuilder.build(bestSelectorSet);\n\n    return selector;\n  }\n}\n", "/**\n * Public API for the Selector Generator library.\n * Provides an IIFE wrapper for backward compatibility with the original implementation.\n */\nimport { SelectorGenerator as SelectorGeneratorClass } from './SelectorGenerator.js';\n\n// Create the wrapped API (same interface as the original)\nconst SelectorGenerator = (function() {\n  'use strict';\n\n  const generator = new SelectorGeneratorClass();\n\n  return {\n    getSelector: (elements) => generator.getSelector(elements)\n  };\n})();\n\n// Set as global for backward compatibility (if in browser)\nif (typeof window !== 'undefined') {\n  window.SelectorGenerator = SelectorGenerator;\n}\n\n// Export for module systems (ESM builds only)\nexport { SelectorGenerator };\nexport { SelectorGeneratorClass };\n"],
  "mappings": "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",
  "names": ["SelectorGenerator"]
}
