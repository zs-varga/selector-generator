{
  "version": 3,
  "sources": ["../src/validators/ElementValidator.js", "../src/services/DOMService.js", "../src/builders/SelectorBuilder.js", "../src/optimizers/BottomUpSelectorOptimizer.js", "../src/optimizers/DebugOptimizer.js", "../src/optimizers/TopDownSelectorOptimizer.js", "../src/config/costs.js", "../src/config/constants.js", "../src/utils/BlacklistMatcher.js", "../src/generators/LocalSelectorGenerator.js", "../src/utils/AttributeCollector.js", "../src/generators/LocalExclusionGenerator.js", "../src/generators/ChildrenSelectorGenerator.js", "../src/generators/ChildrenExclusionGenerator.js", "../src/generators/SiblingSelectorGenerator.js", "../src/generators/ParentSelectorGenerator.js", "../src/SelectorGenerator.js", "../src/index.js"],
  "sourcesContent": ["/**\n * Validates that elements are HTMLElement or SVGElement instances.\n */\nexport class ElementValidator {\n  /**\n   * Checks if an element is valid (HTMLElement or SVGElement).\n   * @param {*} element - The element to validate\n   * @returns {boolean} True if valid, false otherwise\n   */\n  static isValid(element) {\n    return element instanceof HTMLElement || element instanceof SVGElement;\n  }\n\n  /**\n   * Asserts that an element is valid, throws error if not.\n   * @param {*} element - The element to validate\n   * @throws {Error} If element is not HTMLElement or SVGElement\n   */\n  static assertValid(element) {\n    if (!this.isValid(element)) {\n      throw new Error(\"Not an SVG/HTMLElement\");\n    }\n  }\n}\n", "/**\n * Abstraction layer for DOM queries.\n * Allows for easier testing by providing a mockable interface.\n */\nexport class DOMService {\n  /**\n   * Query all elements matching a selector.\n   * @param {string} selector - CSS selector string\n   * @returns {NodeList} List of matching elements\n   */\n  querySelectorAll(selector) {\n    return document.querySelectorAll(selector);\n  }\n\n  /**\n   * Query the first element matching a selector.\n   * @param {string} selector - CSS selector string\n   * @returns {Element|null} First matching element or null\n   */\n  querySelector(selector) {\n    return document.querySelector(selector);\n  }\n}\n", "/**\n * Builds CSS selector strings from selector descriptor sets.\n */\nexport class SelectorBuilder {\n  /**\n   * Builds a selector string from a set of selectors at the same level.\n   * Merges them in proper type order: tag -> id -> class -> attr -> pseudo\n   * @param {Array<SelectorDescriptor>} selectors - Array of selector descriptors at the same level\n   * @returns {string} CSS selector string\n   * @private\n   */\n  #simpleBuild(selectors) {\n    const tagSelectors = selectors.filter((x) => x.type === \"tag\");\n    const idSelectors = selectors.filter((x) => x.type === \"id\");\n    const classSelectors = selectors.filter((x) => x.type === \"class\");\n    const attrSelectors = selectors.filter((x) => x.type === \"attr\");\n    const pseudoSelectors = selectors.filter((x) => x.type === \"pseudo\");\n\n    return (\n      tagSelectors.map((x) => x.selector).join(\"\") +\n      idSelectors.map((x) => x.selector).join(\"\") +\n      classSelectors.map((x) => x.selector).join(\"\") +\n      attrSelectors.map((x) => x.selector).join(\"\") +\n      pseudoSelectors.map((x) => x.selector).join(\"\")\n    );\n  }\n\n  /**\n   * Builds a complete CSS selector string from a set of selector descriptors.\n   * @param {Array<SelectorDescriptor>} selectorSet - Array of selector descriptors\n   * @returns {string} CSS selector string\n   */\n  build(selectorSet) {\n    const tagSelectors = selectorSet.filter(\n      (x) => x.type === \"tag\" && x.level <= 0\n    );\n    const idSelectors = selectorSet.filter(\n      (x) => x.type === \"id\" && x.level <= 0\n    );\n    const classSelectors = selectorSet.filter(\n      (x) => x.type === \"class\" && x.level <= 0\n    );\n    const attrSelectors = selectorSet.filter(\n      (x) => x.type === \"attr\" && x.level <= 0\n    );\n    const pseudoSelectors = selectorSet.filter(\n      (x) => x.type === \"pseudo\" && x.level <= 0\n    );\n    const parentSelectors = selectorSet.filter((x) => x.level > 0);\n\n    let selector =\n      tagSelectors.map((x) => x.selector).join(\"\") +\n      idSelectors.map((x) => x.selector).join(\"\") +\n      classSelectors.map((x) => x.selector).join(\"\") +\n      attrSelectors.map((x) => x.selector).join(\"\") +\n      pseudoSelectors.map((x) => x.selector).join(\"\");\n\n    if (selector === \"\") {\n      selector = \"*\";\n    }\n    \n    if (parentSelectors.length > 0) {\n      // Group parent selectors by level\n      const levelMap = new Map();\n      for (const ps of parentSelectors) {\n        if (!levelMap.has(ps.level)) {\n          levelMap.set(ps.level, []);\n        }\n        levelMap.get(ps.level).push(ps);\n      }\n\n      // Sort levels in ascending order\n      const levels = Array.from(levelMap.keys()).sort((a, b) => a - b);\n\n      let prevLevel = 0;\n      for (const level of levels) {\n        // Use simpleBuild to merge selectors at the same level in proper order\n        const levelSelector = this.#simpleBuild(levelMap.get(level));\n\n        // Add appropriate combinator based on level difference\n        if (level === prevLevel + 1) {\n          selector = levelSelector + \" > \" + selector;\n        } else {\n          selector = levelSelector + \" \" + selector;\n        }\n\n        prevLevel = level;\n      }\n    }\n\n    return selector;\n  }\n}\n", "/**\n * Optimizes selector sets using a bottom-up greedy approach.\n * Starts with empty set and adds selectors that provide the most improvement.\n */\nexport class BottomUpSelectorOptimizer {\n  /**\n   * Creates a BottomUpSelectorOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Calculates the value (specificity score) of a selector set.\n   * Returns the count of elements matching the selector, or Infinity if invalid.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {number} Number of matching elements, or Infinity if invalid\n   */\n  getValue(element, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return Infinity;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    const count = results.length;\n\n    if (count === 0) {\n      console.error(\"Empty selector: \", selector, selectorSet);\n      return Infinity;\n    }\n\n    // Check if element is in results\n    if (!Array.from(results).includes(element)) {\n      console.error(\n        \"Element is missing from selector results: \",\n        selector,\n        selectorSet\n      );\n      return Infinity;\n    }\n\n    return count;\n  }\n\n  /**\n   * Finds the best selector set that uniquely identifies an element.\n   * Uses a greedy optimization algorithm with decreasing thresholds.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectors - Array of all available selector descriptors\n   * @returns {Array<SelectorDescriptor>} Optimized selector set\n   */\n  findBest(element, selectors) {\n    selectors.sort((a, b) => a.cost - b.cost);\n\n    let bestSelectorSet = [];\n    let bestValue = Infinity;\n\n    for (let threshold = 16; threshold >= 1; threshold = threshold / 2) {\n      let improving = true;\n      while (improving) {\n        improving = false;\n\n        let localBestSelectorSet = [...bestSelectorSet];\n        let localBestValue = bestValue;\n        let trialSelectorSet = [...bestSelectorSet];\n        let trialValue = Infinity;\n\n        for (const currentSelector of selectors) {\n          if (trialSelectorSet.includes(currentSelector)) {\n            continue;\n          }\n\n          // Skip parent selectors if there is no other selectors in the set yet\n          if (bestSelectorSet.length === 0 && currentSelector.level > 0) {\n            continue;\n          }\n\n          trialSelectorSet = [...bestSelectorSet, currentSelector];\n          trialValue = this.getValue(element, trialSelectorSet);\n\n          if (localBestValue - trialValue >= threshold) {\n            localBestValue = trialValue;\n            localBestSelectorSet = [...trialSelectorSet];\n          }\n\n          // we found a perfect match\n          if (trialValue === 1) {\n            break;\n          }\n        }\n\n        if (bestValue - localBestValue > 0) {\n          bestSelectorSet = [...localBestSelectorSet];\n          bestValue = localBestValue;\n          if (bestValue === 1) {\n            return bestSelectorSet;\n          }\n          improving = true;\n        }\n\n        if (localBestValue === 1) {\n          break;\n        }\n      }\n    }\n\n    return bestSelectorSet;\n  }\n}\n", "/**\n * Debug optimizer for finding the smallest subset of selectors that does not match the target element.\n * Used when a selectorSet unexpectedly fails to match - helps identify the problematic selector(s).\n */\nexport class DebugOptimizer {\n  /**\n   * Creates a DebugOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Checks if a selector set matches the target element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {boolean} True if element is matched by the selector set\n   */\n  matches(element, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return false;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    return Array.from(results).includes(element);\n  }\n\n  /**\n   * Finds the minimal subset of selectors that does NOT match the target element.\n   * Single pass: removes each selector if the set still doesn't match without it.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectors - Array of selector descriptors (must not match element)\n   * @returns {Array<SelectorDescriptor>} Minimal non-matching subset\n   */\n  findMinimalNonMatchingSet(element, selectors) {\n    let result = [...selectors];\n\n    // Single pass: try removing each selector\n    for (let i = result.length - 1; i >= 0; i--) {\n      // Try the set without this selector\n      const trialSet = result.filter((_, index) => index !== i);\n\n      // If it still doesn't match without this selector, it's redundant - remove it\n      if (!this.matches(element, trialSet)) {\n        result = trialSet;\n      }\n    }\n\n    return result;\n  }\n}\n", "import { DebugOptimizer } from './DebugOptimizer.js';\n\n/**\n * Optimizes selector sets using a top-down approach.\n * Starts with all selectors and removes unnecessary ones while maintaining uniqueness.\n */\nexport class TopDownSelectorOptimizer {\n  /**\n   * Creates a TopDownSelectorOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n    this.debugOptimizer = new DebugOptimizer(domService, selectorBuilder);\n  }\n\n  /**\n   * Calculates the value (specificity score) of a selector set.\n   * Considers both the count of elements matching the selector and the sum of costs.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {{count: number, quality: number}} Object with count and quality, or null if invalid\n   */\n  getValue(element, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return null;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    const count = results.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    // Check if element is in results\n    if (!Array.from(results).includes(element)) {\n      console.error(\n        \"Element is missing from selector results: \",\n        selector,\n        selectorSet\n      );\n      return null;\n    }\n\n    // Calculate sum of costs in the selector set\n    // Lower cost sum = better quality\n    const cost = selectorSet.reduce((sum, descriptor) => sum + descriptor.cost, 0);\n\n    // Return object with both count and quality\n    return { count, cost };\n  }\n\n  /**\n   * Finds the best selector set using top-down optimization with local best solution.\n   * Starts with all selectors and iteratively removes selectors (sorted by cost),\n   * stopping at the first removal that maintains uniqueness (count = 1).\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectors - Array of all available selector descriptors\n   * @returns {Array<SelectorDescriptor>} Optimized selector set\n   */\n  findBest(element, selectors) {\n    // Start with all selectors\n    let currentSet = [...selectors];\n    let currentValue = this.getValue(element, currentSet);\n\n    // If not unique even with all selectors, use debug optimizer to find minimal non-matching set\n    if (!currentValue || currentValue.count !== 1) {\n      console.warn(\n        \"Top-down optimizer: All selectors combined do not produce a unique selector. Finding minimal non-matching subset for debugging.\"\n      );\n      const minimalNonMatching = this.debugOptimizer.findMinimalNonMatchingSet(element, currentSet);\n      console.log(\n        \"The problematic selector is this:\",\n        minimalNonMatching,\n        this.selectorBuilder.build(minimalNonMatching)\n      );\n      return currentSet;\n    }\n\n    // Sort selectors by cost (descending) - highest cost value first (worst quality)\n    // This way we try to remove the worst quality selectors first\n    const sortedSelectors = [...currentSet].sort((a, b) => b.cost - a.cost);\n\n    // Iteratively try removing selectors in cost order\n    let improved = true;\n    while (improved && currentSet.length > 1) {\n      improved = false;\n\n      // Try removing selectors in cost order, stop at first success\n      for (const selectorToRemove of sortedSelectors) {\n        // Skip if selector is no longer in current set (already removed)\n        if (!currentSet.includes(selectorToRemove)) {\n          continue;\n        }\n\n        // Skip removal of level=0, type=tag selectors (base element selector)\n        if (selectorToRemove.level === 0 && selectorToRemove.type === 'tag') {\n          continue;\n        }\n\n        const trialSet = currentSet.filter(s => s !== selectorToRemove);\n        const trialValue = this.getValue(element, trialSet);\n\n        // Check if element still remains unique (count = 1)\n        if (trialValue && trialValue.count === 1) {\n          // Still unique after removal, commit this change and continue\n          currentSet = trialSet;\n          currentValue = trialValue;\n          improved = true;\n          break; // Stop at first improvement and try again\n        }\n      }\n    }\n\n    return currentSet;\n  }\n}\n", "/**\n * Cost constants for selector generation.\n * Lower values indicate higher quality in selector selection.\n */\n\n/*\n\nlocal: id, tag, class, attr\nstructural: parent, child, sibling\nmodifier: not, has\n\n*/\n\nexport const COST_ID = 0;\nexport const COST_CLASS = 1;\nexport const COST_TAG = 2;\nexport const COST_ATTR = 3;\n\nexport const COST_PARENT = 10;\nexport const COST_SIBLING = 100;\nexport const COST_CHILDREN = 100;\nexport const COST_DISTANCE = 1;\n\nexport const COST_IS_HAS = 5; // contains :is(), :has()\nexport const COST_NOT = 10; // contains :not()\n", "/**\n * General constants for selector generation.\n */\n\nexport const IGNORED_ATTRIBUTES = [\"id\", \"style\"];\nexport const IGNORED_ATTRIBUTES_FOR_EXCLUSION = [\"class\", \"style\"];\n\n/**\n * Blacklist patterns for filtering IDs, classes, and attributes.\n * Supports wildcards: * matches any sequence of characters.\n * Examples:\n *   \"*-ng-*\" matches \"app-ng-content\", \"ng-scope\", etc.\n *   \"temp-*\" matches \"temp-123\", \"temp-xyz\", etc.\n *   \"*generated*\" matches \"auto-generated-id\", \"generated\", etc.\n */\nexport const BLACKLIST_IDS = [\n  \"*lottie*\",\n  \"selector-generator\"\n];\n\nexport const BLACKLIST_CLASSES = [\n  \"*-ng-*\", // Angular generated classes\n  \"ng-*\", // Angular directives\n  \"*tw-*\",\n  \"*[*px]*\",\n];\n\nexport const BLACKLIST_ATTRIBUTES = [\n  \"*-ng-*\", // Angular generated classes\n  \"ng-*\", // Angular directives\n  \"*tw-*\",\n  \"xmlns*\",\n];\n", "/**\n * Utility for matching strings against wildcard patterns.\n */\nexport class BlacklistMatcher {\n  /**\n   * Converts a wildcard pattern to a regular expression.\n   * @param {string} pattern - Pattern with * wildcards\n   * @returns {RegExp} Regular expression\n   * @private\n   */\n  static #patternToRegex(pattern) {\n    // Escape special regex characters except *\n    const escaped = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    // Replace * with .*\n    const regexPattern = '^' + escaped.replace(/\\*/g, '.*') + '$';\n    return new RegExp(regexPattern);\n  }\n\n  /**\n   * Checks if a value matches any pattern in the blacklist.\n   * @param {string} value - Value to check\n   * @param {Array<string>} patterns - Array of wildcard patterns\n   * @returns {boolean} True if value matches any pattern\n   */\n  static matches(value, patterns) {\n    if (!value || !patterns || patterns.length === 0) {\n      return false;\n    }\n\n    for (const pattern of patterns) {\n      const regex = this.#patternToRegex(pattern);\n      if (regex.test(value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Filters an array of values, removing those that match blacklist patterns.\n   * @param {Array<string>} values - Values to filter\n   * @param {Array<string>} patterns - Array of wildcard patterns\n   * @returns {Array<string>} Filtered values\n   */\n  static filter(values, patterns) {\n    if (!values || values.length === 0) {\n      return values;\n    }\n\n    if (!patterns || patterns.length === 0) {\n      return values;\n    }\n\n    return values.filter(value => !this.matches(value, patterns));\n  }\n}", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_ID,\n  COST_TAG,\n  COST_CLASS,\n  COST_ATTR,\n} from \"../config/costs.js\";\nimport {\n  IGNORED_ATTRIBUTES,\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from \"../config/constants.js\";\nimport { BlacklistMatcher } from \"../utils/BlacklistMatcher.js\";\n\n/**\n * Generates selectors based on an element's own properties (ID, tag, classes, attributes).\n */\nexport class LocalSelectorGenerator {\n  /**\n   * Generates local selectors for an element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(element) {\n    ElementValidator.assertValid(element);\n\n    const selectors = [];\n\n    // Add ID selector if not blacklisted\n    if (\n      element.id !== \"\" &&\n      !BlacklistMatcher.matches(element.id, BLACKLIST_IDS)\n    ) {\n      selectors.push({\n        cost: COST_ID,\n        level: 0,\n        type: \"id\",\n        selector: \"#\" + CSS.escape(element.id),\n      });\n    }\n\n    // Always add tag selector\n    selectors.push({\n      cost: COST_TAG,\n      level: 0,\n      type: \"tag\",\n      selector: element.localName,\n    });\n\n    for (\n      let i = 0, attributes = element.attributes;\n      i < attributes.length;\n      i++\n    ) {\n      const name = attributes.item(i).name;\n\n      if (IGNORED_ATTRIBUTES.includes(name)) {\n        continue;\n      }\n\n      if (name === \"class\") {\n        element.classList.forEach((currentClass) => {\n          // Skip blacklisted classes\n          if (!BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)) {\n            selectors.push({\n              cost: COST_CLASS,\n              level: 0,\n              type: \"class\",\n              selector: \".\" + CSS.escape(currentClass),\n            });\n          }\n        });\n        continue;\n      }\n\n      // Skip blacklisted attributes\n      if (!BlacklistMatcher.matches(name, BLACKLIST_ATTRIBUTES)) {\n        selectors.push({\n          cost: COST_ATTR,\n          level: 0,\n          type: \"attr\",\n          selector: \"[\" + CSS.escape(name) + \"]\",\n        });\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { BlacklistMatcher } from './BlacklistMatcher.js';\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from '../config/constants.js';\n\n/**\n * Utility class for collecting and analyzing attributes from elements.\n */\nexport class AttributeCollector {\n  /**\n   * Creates an AttributeCollector instance.\n   * @param {HTMLElement|SVGElement} targetElement - The target element to compare against\n   * @param {Array<string>} ignoredAttributes - Attributes to ignore\n   */\n  constructor(targetElement, ignoredAttributes = ['class', 'style']) {\n    this.targetElement = targetElement;\n    this.ignoredAttributes = ignoredAttributes;\n  }\n\n  /**\n   * Collects extra IDs from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped ID values\n   */\n  collectExtraIds(elements) {\n    const extraIds = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      const id = currentElement.getAttribute(\"id\");\n      if (id !== null && !BlacklistMatcher.matches(id, BLACKLIST_IDS)) {\n        extraIds.push(CSS.escape(id));\n      }\n    }\n\n    return extraIds;\n  }\n\n  /**\n   * Collects extra classes from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped class names\n   */\n  collectExtraClasses(elements) {\n    const extraClasses = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      currentElement.classList.forEach((currentClass) => {\n        if (\n          !this.targetElement.classList.contains(currentClass) &&\n          !extraClasses.includes(currentClass) &&\n          !BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)\n        ) {\n          extraClasses.push(CSS.escape(currentClass));\n        }\n      });\n    }\n\n    return extraClasses;\n  }\n\n  /**\n   * Collects extra attributes from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped attribute names\n   */\n  collectExtraAttributes(elements) {\n    const extraAttr = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      const attributes = currentElement.attributes;\n      for (let j = 0; j < attributes.length; j++) {\n        const currentAttr = attributes.item(j);\n        if (\n          !this.ignoredAttributes.includes(currentAttr.name) &&\n          !this.targetElement.hasAttribute(currentAttr.name) &&\n          !extraAttr.includes(currentAttr.name) &&\n          !BlacklistMatcher.matches(currentAttr.name, BLACKLIST_ATTRIBUTES)\n        ) {\n          extraAttr.push(CSS.escape(currentAttr.name));\n        }\n      }\n    }\n\n    return extraAttr;\n  }\n\n  /**\n   * Collects all extra attributes (IDs, classes, attributes) at once.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Object} Object with extraIds, extraClasses, extraAttributes arrays\n   */\n  collectAll(elements) {\n    return {\n      extraIds: this.collectExtraIds(elements),\n      extraClasses: this.collectExtraClasses(elements),\n      extraAttributes: this.collectExtraAttributes(elements),\n    };\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport { AttributeCollector } from \"../utils/AttributeCollector.js\";\nimport {\n  COST_NOT,\n  COST_ATTR,\n  COST_CLASS,\n  COST_ID,\n} from \"../config/costs.js\";\nimport { IGNORED_ATTRIBUTES_FOR_EXCLUSION } from \"../config/constants.js\";\n\n/**\n * Generates :not() pseudo-selectors to exclude similar elements.\n */\nexport class LocalExclusionGenerator {\n  /**\n   * Creates a LocalExclusionGenerator instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, localGenerator, selectorBuilder) {\n    this.domService = domService;\n    this.localGenerator = localGenerator;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Generates exclusion selectors for an element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(element) {\n    ElementValidator.assertValid(element);\n\n    const localSelectors = this.localGenerator.generate(element);\n    const baseSelector = this.selectorBuilder.build(localSelectors);\n    const elements = this.domService.querySelectorAll(baseSelector);\n\n    const selectors = [];\n    const collector = new AttributeCollector(\n      element,\n      IGNORED_ATTRIBUTES_FOR_EXCLUSION\n    );\n\n    const { extraIds, extraClasses, extraAttributes } =\n      collector.collectAll(elements);\n\n    for (let i = 0; i < extraIds.length; i++) {\n      selectors.push({\n        cost: COST_NOT + COST_ID,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":not(#\" + extraIds[i] + \")\",\n      });\n    }\n\n    for (let i = 0; i < extraClasses.length; i++) {\n      selectors.push({\n        cost: COST_NOT + COST_CLASS,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":not(.\" + extraClasses[i] + \")\",\n      });\n    }\n\n    for (let i = 0; i < extraAttributes.length; i++) {\n      selectors.push({\n        cost: COST_NOT + COST_ATTR,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":not([\" + extraAttributes[i] + \"])\",\n      });\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_DISTANCE,\n  COST_CHILDREN,\n  COST_IS_HAS,\n  COST_NOT,\n} from \"../config/costs.js\";\n\n/**\n * Generates selectors based on an element's children.\n */\nexport class ChildrenSelectorGenerator {\n  /**\n   * Creates a ChildrenSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   */\n  constructor(localGenerator) {\n    this.localGenerator = localGenerator;\n  }\n\n  /**\n   * Recursively processes children and their descendants.\n   * @private\n   * @param {HTMLElement|SVGElement} element - Current element being processed\n   * @param {number} depth - Current depth\n   * @param {Array<SelectorDescriptor>} selectors - Accumulator for selector descriptors\n   */\n  #processChildren(element, depth, selectors) {\n    const children = element.children;\n    const depthSelector = \">*\".repeat(depth);\n\n    if (children.length === 0) {\n      // The element contains only text\n      // :has cannot be nested, so we can't do selectors for deeper levels like \":has(>*:not(:has(>*)))\"\n      if (element.childNodes.length > 0 && depth === 0) {\n        selectors.push({\n          cost:\n            depth * COST_DISTANCE + COST_NOT + COST_IS_HAS + COST_CHILDREN,\n          level: 0,\n          type: \"pseudo\",\n          selector: `:not(:has(>*))`,\n        });\n        return selectors;\n      }\n\n      // The element contains nothing OR contains :before OR :after pseudo elements\n      if (element.childNodes.length === 0) {\n        selectors.push({\n          cost: depth * COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n          level: 0,\n          type: \"pseudo\",\n          selector: depth > 0 ? `:has(${depthSelector}:empty)` : `:empty`,\n        });\n        if (depth > 0) {\n          selectors.push({\n            cost: COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n            level: 0,\n            type: \"pseudo\",\n            selector: `:has(:empty)`,\n          });\n        }\n      }\n      return selectors;\n    }\n\n    // has n direct children\n    selectors.push({\n      cost: depth * COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n      level: 0,\n      type: \"pseudo\",\n      selector:\n        depth > 0\n          ? `:has(${depthSelector}>*:nth-child(${children.length}):last-child)`\n          : `:has(:nth-child(${children.length}):last-child)`,\n    });\n    if (depth > 0) {\n      selectors.push({\n        cost: COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n        level: 0,\n        type: \"pseudo\",\n        selector: `:has(* :nth-child(${children.length}):last-child)`,\n      });\n    }\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      const localSelectors = this.localGenerator.generate(child);\n      for (const childrenLocalSelector of localSelectors) {\n        selectors.push({\n          cost:\n            depth * COST_DISTANCE +\n            COST_IS_HAS +\n            COST_CHILDREN +\n            childrenLocalSelector.cost,\n          level: 0,\n          type: \"pseudo\",\n          selector:\n            depth > 0\n              ? `:has(${depthSelector}>${childrenLocalSelector.selector})`\n              : `:has(>${childrenLocalSelector.selector})`,\n        });\n\n        if (depth > 0) {\n          selectors.push({\n            cost:\n              COST_DISTANCE +\n              COST_IS_HAS +\n              COST_CHILDREN +\n              childrenLocalSelector.cost,\n            level: 0,\n            type: \"pseudo\",\n            selector: `:has(* ${childrenLocalSelector.selector})`,\n          });\n        }\n      }\n\n      // Recursively process descendants (go deeper, more negative level)\n      this.#processChildren(child, depth + 1, selectors);\n    }\n  }\n\n  /**\n   * Generates children selectors for an element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(element) {\n    ElementValidator.assertValid(element);\n\n    const selectors = [];\n\n    this.#processChildren(element, 0, selectors);\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_ATTR,\n  COST_CHILDREN,\n  COST_CLASS,\n  COST_IS_HAS,\n  COST_ID,\n  COST_NOT,\n} from \"../config/costs.js\";\nimport {\n  IGNORED_ATTRIBUTES_FOR_EXCLUSION,\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from \"../config/constants.js\";\nimport { BlacklistMatcher } from \"../utils/BlacklistMatcher.js\";\n\n/**\n * Generates :not(:has()) pseudo-selectors to exclude elements based on other elements children\n * If elements differ only by their children, we can select them by the selectors generates by this class\n */\nexport class ChildrenExclusionGenerator {\n  /**\n   * Creates a ChildrenExclusionGenerator instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, localGenerator, selectorBuilder) {\n    this.domService = domService;\n    this.localGenerator = localGenerator;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Generates children exclusion selectors for an element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(element) {\n    ElementValidator.assertValid(element);\n\n    const elementSelector = this.localGenerator.generate(element);\n    const childrenSelector = this.selectorBuilder.build(elementSelector) + \" *\";\n    const allChildren = this.domService.querySelectorAll(childrenSelector);\n\n    const selectors = [];\n\n    const extraClasses = [];\n    const extraAttr = [];\n\n    for (let i = 0; i < allChildren.length; i++) {\n      const currentChild = allChildren[i];\n\n      // Skip children that belong to the element itself\n      if (element.contains(currentChild)) {\n        continue;\n      }\n\n      // Collect extra id (skip if blacklisted)\n      const id = currentChild.getAttribute(\"id\");\n      if (id !== null && !BlacklistMatcher.matches(id, BLACKLIST_IDS)) {\n        selectors.push({\n          cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_ID,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(:has(#\" + CSS.escape(id) + \"))\",\n        });\n      }\n\n      // Collect extra classes (skip if blacklisted)\n      currentChild.classList.forEach((currentClass) => {\n        if (\n          !element.querySelector(\".\" + CSS.escape(currentClass)) &&\n          !extraClasses.includes(currentClass) &&\n          !BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)\n        ) {\n          extraClasses.push(CSS.escape(currentClass));\n        }\n      });\n\n      // Collect extra attributes (skip if blacklisted)\n      const attributes = currentChild.attributes;\n      for (let j = 0; j < attributes.length; j++) {\n        const currentAttr = attributes.item(j);\n        if (\n          !IGNORED_ATTRIBUTES_FOR_EXCLUSION.includes(currentAttr.name) &&\n          !element.querySelector(\"[\" + CSS.escape(currentAttr.name) + \"]\") &&\n          !extraAttr.includes(currentAttr.name) &&\n          !BlacklistMatcher.matches(currentAttr.name, BLACKLIST_ATTRIBUTES)\n        ) {\n          extraAttr.push(CSS.escape(currentAttr.name));\n        }\n      }\n    }\n\n    for (let i = 0; i < extraClasses.length; i++) {\n      selectors.push({\n        cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_CLASS,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":not(:has(.\" + extraClasses[i] + \"))\",\n      });\n    }\n\n    for (let i = 0; i < extraAttr.length; i++) {\n      selectors.push({\n        cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_ATTR,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":not(:has([\" + extraAttr[i] + \"]))\",\n      });\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_DISTANCE,\n  COST_IS_HAS,\n  COST_SIBLING,\n} from \"../config/costs.js\";\n\n/**\n * Generates selectors based on sibling relationships.\n */\nexport class SiblingSelectorGenerator {\n  /**\n   * Creates a SiblingSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   */\n  constructor(localGenerator) {\n    this.localGenerator = localGenerator;\n  }\n\n  /**\n   * Generates sibling selectors for an element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(element) {\n    ElementValidator.assertValid(element);\n\n    const selectors = [];\n\n    let prevSibling = element.previousElementSibling;\n    const prevSiblingCount =\n      prevSibling !== null\n        ? Array.from(element.parentElement.children).indexOf(element)\n        : 0;\n\n    let nextSibling = element.nextElementSibling;\n    const nextSiblingCount =\n      nextSibling !== null\n        ? Array.from(element.parentElement.children).length -\n          Array.from(element.parentElement.children).indexOf(element)\n        : 0;\n\n    if (prevSibling === null) {\n      // there is no previous sibling\n      selectors.push({\n        cost: (nextSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":first-child\",\n      });\n    } else {\n      // there are previous siblings\n      selectors.push({\n        cost: (prevSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":nth-child(\" + (prevSiblingCount + 1) + \")\",\n      });\n    }\n\n    if (nextSibling === null) {\n      // there is no next sibling\n      selectors.push({\n        cost: (prevSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":last-child\",\n      });\n    } else {\n      // there are next siblings, so we can use nth-last-child\n      // however, we will only use this if there are prev siblings too\n      // if there are not, nth-child is better\n      if (prevSiblingCount > 0) {\n        selectors.push({\n          cost: (nextSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":nth-last-child(\" + nextSiblingCount + \")\",\n        });\n      }\n    }\n\n    if (prevSibling === null && nextSibling === null) {\n      selectors.push({\n        cost: COST_SIBLING,\n        level: 0,\n        type: \"pseudo\",\n        selector: \":only-child\",\n      });\n    }\n\n    while (prevSibling) {\n      if (prevSibling.nodeType === Node.COMMENT_NODE) {\n        prevSibling = prevSibling.previousElementSibling;\n        continue;\n      }\n      if (prevSibling.nodeType === Node.TEXT_NODE) {\n        prevSibling = prevSibling.previousElementSibling;\n        continue;\n      }\n\n      const localSelectors = this.localGenerator.generate(prevSibling);\n      for (const currentSelector of localSelectors) {\n        if (\n          !selectors.some(\n            (s) => s.selector === \":is(\" + currentSelector.selector + \" ~ *)\"\n          )\n        ) {\n          selectors.push({\n            cost: COST_SIBLING + COST_IS_HAS + currentSelector.cost,\n            level: 0,\n            type: \"pseudo\",\n            selector: \":is(\" + currentSelector.selector + \" ~ *)\",\n          });\n        }\n      }\n      prevSibling = prevSibling.previousElementSibling;\n    }\n\n    while (nextSibling) {\n      if (nextSibling.nodeType === Node.COMMENT_NODE) {\n        nextSibling = nextSibling.nextElementSibling;\n        continue;\n      }\n      if (nextSibling.nodeType === Node.TEXT_NODE) {\n        nextSibling = nextSibling.nextElementSibling;\n        continue;\n      }\n\n      const localSelectors = this.localGenerator.generate(nextSibling);\n      for (const currentSelector of localSelectors) {\n        if (\n          !selectors.some(\n            (s) => s.selector === \":has(~ \" + currentSelector.selector + \")\"\n          )\n        ) {\n          selectors.push({\n            cost: COST_SIBLING + COST_IS_HAS + currentSelector.cost,\n            level: 0,\n            type: \"pseudo\",\n            selector: \":has(~ \" + currentSelector.selector + \")\",\n          });\n        }\n      }\n      nextSibling = nextSibling.nextElementSibling;\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport { COST_DISTANCE, COST_PARENT } from \"../config/costs.js\";\n\n/**\n * Generates selectors based on parent elements.\n */\nexport class ParentSelectorGenerator {\n  /**\n   * Creates a ParentSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {LocalExclusionGenerator} exclusionGenerator - Generator for exclusion selectors\n   * @param {SiblingSelectorGenerator} siblingGenerator - Generator for sibling selectors\n   */\n  constructor(localGenerator, exclusionGenerator, siblingGenerator) {\n    this.localGenerator = localGenerator;\n    this.exclusionGenerator = exclusionGenerator;\n    this.siblingGenerator = siblingGenerator;\n  }\n\n  /**\n   * Generates parent selectors for an element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(element) {\n    ElementValidator.assertValid(element);\n\n    const selectors = [];\n\n    let currentParent = element.parentElement;\n    let level = 1;\n\n    while (currentParent) {\n      const localSelectors = this.localGenerator.generate(currentParent);\n      for (const currentSelector of localSelectors) {\n        selectors.push({\n          cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n          level: level,\n          type: currentSelector.type,\n          selector: currentSelector.selector,\n        });\n      }\n\n      const localExclSelectors =\n        this.exclusionGenerator.generate(currentParent);\n      for (const currentSelector of localExclSelectors) {\n        selectors.push({\n          cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n          level: level,\n          type: currentSelector.type,\n          selector: currentSelector.selector,\n        });\n      }\n\n      const siblingSelectors = this.siblingGenerator.generate(currentParent);\n      for (const currentSelector of siblingSelectors) {\n        selectors.push({\n          cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n          level: level,\n          type: currentSelector.type,\n          selector: currentSelector.selector,\n        });\n      }\n\n      currentParent = currentParent.parentElement;\n      level = level + 1;\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from './validators/ElementValidator.js';\nimport { DOMService } from './services/DOMService.js';\nimport { SelectorBuilder } from './builders/SelectorBuilder.js';\nimport { BottomUpSelectorOptimizer } from './optimizers/BottomUpSelectorOptimizer.js';\nimport { TopDownSelectorOptimizer } from './optimizers/TopDownSelectorOptimizer.js';\nimport { LocalSelectorGenerator } from './generators/LocalSelectorGenerator.js';\nimport { LocalExclusionGenerator } from './generators/LocalExclusionGenerator.js';\nimport { ChildrenSelectorGenerator } from './generators/ChildrenSelectorGenerator.js';\nimport { ChildrenExclusionGenerator } from './generators/ChildrenExclusionGenerator.js';\nimport { SiblingSelectorGenerator } from './generators/SiblingSelectorGenerator.js';\nimport { ParentSelectorGenerator } from './generators/ParentSelectorGenerator.js';\n\n/**\n * Main class for generating optimal CSS selectors for DOM elements.\n */\nexport class SelectorGenerator {\n  constructor() {\n    // Initialize services\n    this.domService = new DOMService();\n    this.selectorBuilder = new SelectorBuilder();\n    this.bottomUpOptimizer = new BottomUpSelectorOptimizer(this.domService, this.selectorBuilder);\n    this.topDownOptimizer = new TopDownSelectorOptimizer(this.domService, this.selectorBuilder);\n\n    // Initialize generators\n    this.localGenerator = new LocalSelectorGenerator();\n    this.exclusionGenerator = new LocalExclusionGenerator(\n      this.domService,\n      this.localGenerator,\n      this.selectorBuilder\n    );\n    this.childrenGenerator = new ChildrenSelectorGenerator(this.localGenerator);\n    this.childrenExclusionGenerator = new ChildrenExclusionGenerator(\n      this.domService,\n      this.localGenerator,\n      this.selectorBuilder\n    );\n    this.siblingGenerator = new SiblingSelectorGenerator(this.localGenerator);\n    this.parentGenerator = new ParentSelectorGenerator(\n      this.localGenerator,\n      this.exclusionGenerator,\n      this.siblingGenerator\n    );\n  }\n\n  /**\n   * Generates an optimal CSS selector for the given element.\n   * Uses a hybrid approach: tries bottom-up optimization first,\n   * and falls back to top-down if a unique selector is not found.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @returns {string} CSS selector string that uniquely identifies the element\n   */\n  getSelector(element) {\n    ElementValidator.assertValid(element);\n\n    let selectors = [];\n\n    selectors = selectors.concat(this.localGenerator.generate(element));\n    selectors = selectors.concat(this.exclusionGenerator.generate(element));\n    selectors = selectors.concat(this.childrenGenerator.generate(element));\n    selectors = selectors.concat(this.siblingGenerator.generate(element));\n    selectors = selectors.concat(this.parentGenerator.generate(element));\n    selectors = selectors.concat(this.childrenExclusionGenerator.generate(element));\n\n    /*\n    // Try bottom-up optimization first (fast, works for most cases)\n    let bestSelectorSet = this.bottomUpOptimizer.findBest(element, selectors);\n    let value = this.bottomUpOptimizer.getValue(element, bestSelectorSet);\n\n    // If bottom-up didn't find a unique selector, try top-down\n    if (value !== 1) {\n      bestSelectorSet = this.topDownOptimizer.findBest(element, selectors);\n    }\n    */\n\n    let bestSelectorSet = this.topDownOptimizer.findBest(element, selectors);\n\n    const selector = this.selectorBuilder.build(bestSelectorSet);\n\n    return selector;\n  }\n}\n", "/**\n * Public API for the Selector Generator library.\n * Provides an IIFE wrapper for backward compatibility with the original implementation.\n */\nimport { SelectorGenerator as SelectorGeneratorClass } from './SelectorGenerator.js';\n\n// Create the wrapped API (same interface as the original)\nconst SelectorGenerator = (function() {\n  'use strict';\n\n  const generator = new SelectorGeneratorClass();\n\n  return {\n    getSelector: (element) => generator.getSelector(element)\n  };\n})();\n\n// Set as global for backward compatibility (if in browser)\nif (typeof window !== 'undefined') {\n  window.SelectorGenerator = SelectorGenerator;\n}\n\n// Export for module systems (ESM builds only)\nexport { SelectorGenerator };\nexport { SelectorGeneratorClass };\n"],
  "mappings": "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",
  "names": ["SelectorGenerator"]
}
