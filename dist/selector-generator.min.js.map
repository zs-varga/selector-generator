{
  "version": 3,
  "sources": ["../src/validators/ElementValidator.js", "../src/services/DOMService.js", "../src/builders/SelectorBuilder.js", "../src/optimizers/BottomUpSelectorOptimizer.js", "../src/optimizers/DebugOptimizer.js", "../src/optimizers/TopDownSelectorOptimizer.js", "../src/config/constants.js", "../src/utils/BlacklistMatcher.js", "../src/generators/LocalSelectorGenerator.js", "../src/utils/AttributeCollector.js", "../src/generators/LocalExclusionGenerator.js", "../src/generators/ChildrenSelectorGenerator.js", "../src/generators/ChildrenExclusionGenerator.js", "../src/generators/SiblingSelectorGenerator.js", "../src/generators/ParentSelectorGenerator.js", "../src/SelectorGenerator.js", "../src/index.js"],
  "sourcesContent": ["/**\n * Validates that elements are HTMLElement or SVGElement instances.\n */\nexport class ElementValidator {\n  /**\n   * Checks if an element is valid (HTMLElement or SVGElement).\n   * @param {*} element - The element to validate\n   * @returns {boolean} True if valid, false otherwise\n   */\n  static isValid(element) {\n    return element instanceof HTMLElement || element instanceof SVGElement;\n  }\n\n  /**\n   * Asserts that an element is valid, throws error if not.\n   * @param {*} element - The element to validate\n   * @throws {Error} If element is not HTMLElement or SVGElement\n   */\n  static assertValid(element) {\n    if (!this.isValid(element)) {\n      throw new Error(\"Not an SVG/HTMLElement\");\n    }\n  }\n}\n", "/**\n * Abstraction layer for DOM queries.\n * Allows for easier testing by providing a mockable interface.\n */\nexport class DOMService {\n  /**\n   * Query all elements matching a selector.\n   * @param {string} selector - CSS selector string\n   * @returns {NodeList} List of matching elements\n   */\n  querySelectorAll(selector) {\n    return document.querySelectorAll(selector);\n  }\n\n  /**\n   * Query the first element matching a selector.\n   * @param {string} selector - CSS selector string\n   * @returns {Element|null} First matching element or null\n   */\n  querySelector(selector) {\n    return document.querySelector(selector);\n  }\n}\n", "/**\n * Builds CSS selector strings from selector descriptor sets.\n */\nexport class SelectorBuilder {\n  /**\n   * Builds a selector string from a set of selectors at the same level.\n   * Merges them in proper type order: tag -> id -> class -> attr -> pseudo\n   * @param {Array<SelectorDescriptor>} selectors - Array of selector descriptors at the same level\n   * @returns {string} CSS selector string\n   * @private\n   */\n  #simpleBuild(selectors) {\n    const tagSelectors = selectors.filter((x) => x.type === \"tag\");\n    const idSelectors = selectors.filter((x) => x.type === \"id\");\n    const classSelectors = selectors.filter((x) => x.type === \"class\");\n    const attrSelectors = selectors.filter((x) => x.type === \"attr\");\n    const pseudoSelectors = selectors.filter((x) => x.type === \"pseudo\");\n\n    return (\n      tagSelectors.map((x) => x.selector).join(\"\") +\n      idSelectors.map((x) => x.selector).join(\"\") +\n      classSelectors.map((x) => x.selector).join(\"\") +\n      attrSelectors.map((x) => x.selector).join(\"\") +\n      pseudoSelectors.map((x) => x.selector).join(\"\")\n    );\n  }\n\n  /**\n   * Builds a complete CSS selector string from a set of selector descriptors.\n   * @param {Array<SelectorDescriptor>} selectorSet - Array of selector descriptors\n   * @returns {string} CSS selector string\n   */\n  build(selectorSet) {\n    const tagSelectors = selectorSet.filter(\n      (x) => x.type === \"tag\" && x.level <= 0\n    );\n    const idSelectors = selectorSet.filter(\n      (x) => x.type === \"id\" && x.level <= 0\n    );\n    const classSelectors = selectorSet.filter(\n      (x) => x.type === \"class\" && x.level <= 0\n    );\n    const attrSelectors = selectorSet.filter(\n      (x) => x.type === \"attr\" && x.level <= 0\n    );\n    const pseudoSelectors = selectorSet.filter(\n      (x) => x.type === \"pseudo\" && x.level <= 0\n    );\n    const parentSelectors = selectorSet.filter((x) => x.level > 0);\n\n    let selector =\n      tagSelectors.map((x) => x.selector).join(\"\") +\n      idSelectors.map((x) => x.selector).join(\"\") +\n      classSelectors.map((x) => x.selector).join(\"\") +\n      attrSelectors.map((x) => x.selector).join(\"\") +\n      pseudoSelectors.map((x) => x.selector).join(\"\");\n\n    if (selector === \"\") {\n      selector = \"*\";\n    }\n    \n    if (parentSelectors.length > 0) {\n      // Group parent selectors by level\n      const levelMap = new Map();\n      for (const ps of parentSelectors) {\n        if (!levelMap.has(ps.level)) {\n          levelMap.set(ps.level, []);\n        }\n        levelMap.get(ps.level).push(ps);\n      }\n\n      // Sort levels in ascending order\n      const levels = Array.from(levelMap.keys()).sort((a, b) => a - b);\n\n      let prevLevel = 0;\n      for (const level of levels) {\n        // Use simpleBuild to merge selectors at the same level in proper order\n        const levelSelector = this.#simpleBuild(levelMap.get(level));\n\n        // Add appropriate combinator based on level difference\n        if (level === prevLevel + 1) {\n          selector = levelSelector + \" > \" + selector;\n        } else {\n          selector = levelSelector + \" \" + selector;\n        }\n\n        prevLevel = level;\n      }\n    }\n\n    return selector;\n  }\n}\n", "/**\n * Optimizes selector sets using a bottom-up greedy approach.\n * Starts with empty set and adds selectors that provide the most improvement.\n */\nexport class BottomUpSelectorOptimizer {\n  /**\n   * Creates a BottomUpSelectorOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Calculates the value (specificity score) of a selector set.\n   * Returns the count of elements matching the selector, or Infinity if invalid.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {number} Number of matching elements, or Infinity if invalid\n   */\n  getValue(elements, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return Infinity;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    const count = results.length;\n\n    if (count === 0) {\n      console.error(\"Empty selector: \", selector, selectorSet);\n      return Infinity;\n    }\n\n    const resultsArray = Array.from(results);\n\n    // Check if all target elements are in results\n    for (const element of elements) {\n      if (!resultsArray.includes(element)) {\n        console.error(\n          \"Element is missing from selector results: \",\n          selector,\n          selectorSet\n        );\n        return Infinity;\n      }\n    }\n\n    return count;\n  }\n\n  /**\n   * Finds the best selector set that identifies all target elements.\n   * Uses a greedy optimization algorithm with decreasing thresholds.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectors - Array of all available selector descriptors\n   * @returns {Array<SelectorDescriptor>} Optimized selector set\n   */\n  findBest(elements, selectors) {\n    selectors.sort((a, b) => a.cost - b.cost);\n\n    let bestSelectorSet = [];\n    let bestValue = Infinity;\n    const targetCount = elements.length;\n\n    for (let threshold = 16; threshold >= 1; threshold = threshold / 2) {\n      let improving = true;\n      while (improving) {\n        improving = false;\n\n        let localBestSelectorSet = [...bestSelectorSet];\n        let localBestValue = bestValue;\n        let trialSelectorSet = [...bestSelectorSet];\n        let trialValue = Infinity;\n\n        for (const currentSelector of selectors) {\n          if (trialSelectorSet.includes(currentSelector)) {\n            continue;\n          }\n\n          // Skip parent selectors if there is no other selectors in the set yet\n          if (bestSelectorSet.length === 0 && currentSelector.level > 0) {\n            continue;\n          }\n\n          trialSelectorSet = [...bestSelectorSet, currentSelector];\n          trialValue = this.getValue(elements, trialSelectorSet);\n\n          if (localBestValue - trialValue >= threshold) {\n            localBestValue = trialValue;\n            localBestSelectorSet = [...trialSelectorSet];\n          }\n\n          // we found a perfect match\n          if (trialValue === targetCount) {\n            break;\n          }\n        }\n\n        if (bestValue - localBestValue > 0) {\n          bestSelectorSet = [...localBestSelectorSet];\n          bestValue = localBestValue;\n          if (bestValue === targetCount) {\n            return bestSelectorSet;\n          }\n          improving = true;\n        }\n\n        if (localBestValue === targetCount) {\n          break;\n        }\n      }\n    }\n\n    return bestSelectorSet;\n  }\n}\n", "/**\n * Debug optimizer for finding the smallest subset of selectors that does not match the target element.\n * Used when a selectorSet unexpectedly fails to match - helps identify the problematic selector(s).\n */\nexport class DebugOptimizer {\n  /**\n   * Creates a DebugOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Checks if a selector set matches the target element.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {boolean} True if element is matched by the selector set\n   */\n  matches(element, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return false;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    return Array.from(results).includes(element);\n  }\n\n  /**\n   * Finds the minimal subset of selectors that does NOT match the target element.\n   * Single pass: removes each selector if the set still doesn't match without it.\n   * @param {HTMLElement|SVGElement} element - The target element\n   * @param {Array<SelectorDescriptor>} selectors - Array of selector descriptors (must not match element)\n   * @returns {Array<SelectorDescriptor>} Minimal non-matching subset\n   */\n  findMinimalNonMatchingSet(element, selectors) {\n    let result = [...selectors];\n\n    // Single pass: try removing each selector\n    for (let i = result.length - 1; i >= 0; i--) {\n      // Try the set without this selector\n      const trialSet = result.filter((_, index) => index !== i);\n\n      // If it still doesn't match without this selector, it's redundant - remove it\n      if (!this.matches(element, trialSet)) {\n        result = trialSet;\n      }\n    }\n\n    return result;\n  }\n}\n", "import { DebugOptimizer } from './DebugOptimizer.js';\n\n/**\n * Optimizes selector sets using a top-down approach.\n * Starts with all selectors and removes unnecessary ones while maintaining uniqueness.\n */\nexport class TopDownSelectorOptimizer {\n  /**\n   * Creates a TopDownSelectorOptimizer instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, selectorBuilder) {\n    this.domService = domService;\n    this.selectorBuilder = selectorBuilder;\n    this.debugOptimizer = new DebugOptimizer(domService, selectorBuilder);\n  }\n\n  /**\n   * Calculates the value (specificity score) of a selector set.\n   * Considers both the count of elements matching the selector and the sum of costs.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectorSet - Set of selector descriptors\n   * @returns {{count: number, quality: number}} Object with count and quality, or null if invalid\n   */\n  getValue(elements, selectorSet) {\n    const selector = this.selectorBuilder.build(selectorSet);\n    if (selector === \"\") {\n      return null;\n    }\n    const results = this.domService.querySelectorAll(selector);\n    const count = results.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const resultsArray = Array.from(results);\n\n    // Check if all target elements are in results\n    for (const element of elements) {\n      if (!resultsArray.includes(element)) {\n        console.error(\n          \"Element is missing from selector results: \",\n          selector,\n          selectorSet\n        );\n        return null;\n      }\n    }\n\n    // Calculate sum of costs in the selector set\n    // Lower cost sum = better quality\n    const cost = selectorSet.reduce((sum, descriptor) => sum + descriptor.cost, 0);\n\n    // Return object with both count and quality\n    return { count, cost };\n  }\n\n  /**\n   * Finds the best selector set using top-down optimization with local best solution.\n   * Starts with all selectors and iteratively removes selectors (sorted by cost),\n   * stopping at the first removal that maintains uniqueness (count = elements.length).\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @param {Array<SelectorDescriptor>} selectors - Array of all available selector descriptors\n   * @returns {Array<SelectorDescriptor>} Optimized selector set\n   */\n  findBest(elements, selectors) {\n    // Start with all selectors\n    let currentSet = [...selectors];\n    let currentValue = this.getValue(elements, currentSet);\n\n    const targetCount = elements.length;\n\n    // If not unique even with all selectors, use debug optimizer to find minimal non-matching set\n    if (!currentValue || currentValue.count !== targetCount) {\n      console.warn(\n        `Top-down optimizer: All selectors combined do not produce a selector matching exactly ${targetCount} element(s). Finding minimal non-matching subset for debugging.`\n      );\n      const minimalNonMatching = this.debugOptimizer.findMinimalNonMatchingSet(elements[0], currentSet);\n      console.log(\n        \"The problematic selector is this:\",\n        minimalNonMatching,\n        this.selectorBuilder.build(minimalNonMatching)\n      );\n      return currentSet;\n    }\n\n    // Sort selectors by cost (descending) - highest cost value first (worst quality)\n    // This way we try to remove the worst quality selectors first\n    const sortedSelectors = [...currentSet].sort((a, b) => b.cost - a.cost);\n\n    // Iteratively try removing selectors in cost order\n    let improved = true;\n    while (improved && currentSet.length > 1) {\n      improved = false;\n\n      // Try removing selectors in cost order, stop at first success\n      for (const selectorToRemove of sortedSelectors) {\n        // Skip if selector is no longer in current set (already removed)\n        if (!currentSet.includes(selectorToRemove)) {\n          continue;\n        }\n\n        // Skip removal of level=0, type=tag selectors (base element selector)\n        if (selectorToRemove.level === 0 && selectorToRemove.type === 'tag') {\n          continue;\n        }\n\n        const trialSet = currentSet.filter(s => s !== selectorToRemove);\n        const trialValue = this.getValue(elements, trialSet);\n\n        // Check if elements still match exactly (count = targetCount)\n        if (trialValue && trialValue.count === targetCount) {\n          // Still matching after removal, commit this change and continue\n          currentSet = trialSet;\n          currentValue = trialValue;\n          improved = true;\n          break; // Stop at first improvement and try again\n        }\n      }\n    }\n\n    return currentSet;\n  }\n}\n", "/**\n * Blacklist patterns for filtering IDs, classes, and attributes.\n * Supports wildcards: * matches any sequence of characters.\n * Examples:\n *   \"*-ng-*\" matches \"app-ng-content\", \"ng-scope\", etc.\n *   \"temp-*\" matches \"temp-123\", \"temp-xyz\", etc.\n *   \"*generated*\" matches \"auto-generated-id\", \"generated\", etc.\n */\nexport const BLACKLIST_IDS = [\n  \"*lottie*\",\n  \"selector-generator\"\n];\n\nexport const BLACKLIST_CLASSES = [\n  \"*-ng-*\", // Angular generated classes\n  \"ng-*\", // Angular directives\n  \"*tw-*\",\n  \"*[*px]*\",\n];\n\nexport const BLACKLIST_ATTRIBUTES = [\n  \"id\",\n  \"style\",\n  \"*-ng-*\", // Angular generated classes\n  \"ng-*\", // Angular directives\n  \"*tw-*\",\n  \"xmlns*\",\n];\n", "/**\n * Utility for matching strings against wildcard patterns.\n */\nexport class BlacklistMatcher {\n  /**\n   * Converts a wildcard pattern to a regular expression.\n   * @param {string} pattern - Pattern with * wildcards\n   * @returns {RegExp} Regular expression\n   * @private\n   */\n  static #patternToRegex(pattern) {\n    // Escape special regex characters except *\n    const escaped = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    // Replace * with .*\n    const regexPattern = '^' + escaped.replace(/\\*/g, '.*') + '$';\n    return new RegExp(regexPattern);\n  }\n\n  /**\n   * Checks if a value matches any pattern in the blacklist.\n   * @param {string} value - Value to check\n   * @param {Array<string>} patterns - Array of wildcard patterns\n   * @returns {boolean} True if value matches any pattern\n   */\n  static matches(value, patterns) {\n    if (!value || !patterns || patterns.length === 0) {\n      return false;\n    }\n\n    for (const pattern of patterns) {\n      const regex = this.#patternToRegex(pattern);\n      if (regex.test(value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Filters an array of values, removing those that match blacklist patterns.\n   * @param {Array<string>} values - Values to filter\n   * @param {Array<string>} patterns - Array of wildcard patterns\n   * @returns {Array<string>} Filtered values\n   */\n  static filter(values, patterns) {\n    if (!values || values.length === 0) {\n      return values;\n    }\n\n    if (!patterns || patterns.length === 0) {\n      return values;\n    }\n\n    return values.filter(value => !this.matches(value, patterns));\n  }\n}", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_ID,\n  COST_TAG,\n  COST_CLASS,\n  COST_ATTR,\n} from \"../config/costs.js\";\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from \"../config/constants.js\";\nimport { BlacklistMatcher } from \"../utils/BlacklistMatcher.js\";\n\n/**\n * Generates selectors based on an element's own properties (ID, tag, classes, attributes).\n */\nexport class LocalSelectorGenerator {\n  /**\n   * Generates local selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Get selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      // Add ID selector if not blacklisted\n      if (\n        element.id !== \"\" &&\n        !BlacklistMatcher.matches(element.id, BLACKLIST_IDS)\n      ) {\n        sels.push({\n          cost: COST_ID,\n          level: 0,\n          type: \"id\",\n          selector: \"#\" + CSS.escape(element.id),\n        });\n      }\n\n      // Always add tag selector\n      sels.push({\n        cost: COST_TAG,\n        level: 0,\n        type: \"tag\",\n        selector: element.localName,\n      });\n\n      for (\n        let i = 0, attributes = element.attributes;\n        i < attributes.length;\n        i++\n      ) {\n        const name = attributes.item(i).name;\n\n        if (name === \"class\") {\n          element.classList.forEach((currentClass) => {\n            // Skip blacklisted classes\n            if (!BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)) {\n              sels.push({\n                cost: COST_CLASS,\n                level: 0,\n                type: \"class\",\n                selector: \".\" + CSS.escape(currentClass),\n              });\n            }\n          });\n          continue;\n        }\n\n        // Skip blacklisted attributes\n        if (!BlacklistMatcher.matches(name, BLACKLIST_ATTRIBUTES)) {\n          sels.push({\n            cost: COST_ATTR,\n            level: 0,\n            type: \"attr\",\n            selector: \"[\" + CSS.escape(name) + \"]\",\n          });\n        }\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(d => d.selector === descriptor.selector)\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { BlacklistMatcher } from './BlacklistMatcher.js';\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from '../config/constants.js';\n\n/**\n * Utility class for collecting and analyzing attributes from elements.\n */\nexport class AttributeCollector {\n  /**\n   * Creates an AttributeCollector instance.\n   * @param {HTMLElement|SVGElement} targetElement - The target element to compare against\n   */\n  constructor(targetElement) {\n    this.targetElement = targetElement;\n  }\n\n  /**\n   * Collects extra IDs from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped ID values\n   */\n  collectExtraIds(elements) {\n    const extraIds = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      const id = currentElement.getAttribute(\"id\");\n      if (id !== null && !BlacklistMatcher.matches(id, BLACKLIST_IDS)) {\n        extraIds.push(CSS.escape(id));\n      }\n    }\n\n    return extraIds;\n  }\n\n  /**\n   * Collects extra classes from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped class names\n   */\n  collectExtraClasses(elements) {\n    const extraClasses = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      currentElement.classList.forEach((currentClass) => {\n        if (\n          !this.targetElement.classList.contains(currentClass) &&\n          !extraClasses.includes(currentClass) &&\n          !BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)\n        ) {\n          extraClasses.push(CSS.escape(currentClass));\n        }\n      });\n    }\n\n    return extraClasses;\n  }\n\n  /**\n   * Collects extra attributes from elements that the target doesn't have.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Array<string>} Array of CSS-escaped attribute names\n   */\n  collectExtraAttributes(elements) {\n    const extraAttr = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const currentElement = elements[i];\n\n      if (currentElement === this.targetElement) {\n        continue;\n      }\n\n      const attributes = currentElement.attributes;\n      for (let j = 0; j < attributes.length; j++) {\n        const currentAttr = attributes.item(j);\n        if (\n          !this.targetElement.hasAttribute(currentAttr.name) &&\n          !extraAttr.includes(currentAttr.name) &&\n          !BlacklistMatcher.matches(currentAttr.name, BLACKLIST_ATTRIBUTES)\n        ) {\n          extraAttr.push(CSS.escape(currentAttr.name));\n        }\n      }\n    }\n\n    return extraAttr;\n  }\n\n  /**\n   * Collects all extra attributes (IDs, classes, attributes) at once.\n   * @param {NodeList|Array} elements - Elements to analyze\n   * @returns {Object} Object with extraIds, extraClasses, extraAttributes arrays\n   */\n  collectAll(elements) {\n    return {\n      extraIds: this.collectExtraIds(elements),\n      extraClasses: this.collectExtraClasses(elements),\n      extraAttributes: this.collectExtraAttributes(elements),\n    };\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport { AttributeCollector } from \"../utils/AttributeCollector.js\";\nimport {\n  COST_NOT,\n  COST_ATTR,\n  COST_CLASS,\n  COST_ID,\n} from \"../config/costs.js\";\n\n/**\n * Generates :not() pseudo-selectors to exclude similar elements.\n */\nexport class LocalExclusionGenerator {\n  /**\n   * Creates a LocalExclusionGenerator instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, localGenerator, selectorBuilder) {\n    this.domService = domService;\n    this.localGenerator = localGenerator;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Generates exclusion selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate exclusion selectors for each element\n    const elementExclusions = elements.map(element => {\n      const localSelectors = this.localGenerator.generate([element]);\n      const baseSelector = this.selectorBuilder.build(localSelectors);\n      const matchedElements = this.domService.querySelectorAll(baseSelector);\n\n      const exclSelectors = [];\n      const collector = new AttributeCollector(element);\n\n      const { extraIds, extraClasses, extraAttributes } =\n        collector.collectAll(matchedElements);\n\n      for (let i = 0; i < extraIds.length; i++) {\n        exclSelectors.push({\n          cost: COST_NOT + COST_ID,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(#\" + extraIds[i] + \")\",\n        });\n      }\n\n      for (let i = 0; i < extraClasses.length; i++) {\n        exclSelectors.push({\n          cost: COST_NOT + COST_CLASS,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(.\" + extraClasses[i] + \")\",\n        });\n      }\n\n      for (let i = 0; i < extraAttributes.length; i++) {\n        exclSelectors.push({\n          cost: COST_NOT + COST_ATTR,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not([\" + extraAttributes[i] + \"])\",\n        });\n      }\n\n      return exclSelectors;\n    });\n\n    // Find common selectors across all elements\n    if (elementExclusions.length === 0) return selectors;\n\n    const firstSet = elementExclusions[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementExclusions.every(set =>\n        set.some(d => d.selector === descriptor.selector)\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_DISTANCE,\n  COST_CHILDREN,\n  COST_IS_HAS,\n  COST_NOT,\n} from \"../config/costs.js\";\n\n/**\n * Generates selectors based on an element's children.\n */\nexport class ChildrenSelectorGenerator {\n  /**\n   * Creates a ChildrenSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   */\n  constructor(localGenerator) {\n    this.localGenerator = localGenerator;\n  }\n\n  /**\n   * Recursively processes children and their descendants.\n   * @private\n   * @param {HTMLElement|SVGElement} element - Current element being processed\n   * @param {number} depth - Current depth\n   * @param {Array<SelectorDescriptor>} selectors - Accumulator for selector descriptors\n   */\n  #processChildren(element, depth, selectors) {\n    const children = element.children;\n    const depthSelector = \">*\".repeat(depth);\n\n    if (children.length === 0) {\n      // The element contains only text\n      // :has cannot be nested, so we can't do selectors for deeper levels like \":has(>*:not(:has(>*)))\"\n      if (element.childNodes.length > 0 && depth === 0) {\n        selectors.push({\n          cost:\n            depth * COST_DISTANCE + COST_NOT + COST_IS_HAS + COST_CHILDREN,\n          level: 0,\n          type: \"pseudo\",\n          selector: `:not(:has(>*))`,\n        });\n        return selectors;\n      }\n\n      // The element contains nothing OR contains :before OR :after pseudo elements\n      if (element.childNodes.length === 0) {\n        selectors.push({\n          cost: depth * COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n          level: 0,\n          type: \"pseudo\",\n          selector: depth > 0 ? `:has(${depthSelector}:empty)` : `:empty`,\n        });\n        if (depth > 0) {\n          selectors.push({\n            cost: COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n            level: 0,\n            type: \"pseudo\",\n            selector: `:has(:empty)`,\n          });\n        }\n      }\n      return selectors;\n    }\n\n    // has n direct children\n    selectors.push({\n      cost: depth * COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n      level: 0,\n      type: \"pseudo\",\n      selector:\n        depth > 0\n          ? `:has(${depthSelector}>*:nth-child(${children.length}):last-child)`\n          : `:has(:nth-child(${children.length}):last-child)`,\n    });\n    if (depth > 0) {\n      selectors.push({\n        cost: COST_DISTANCE + COST_IS_HAS + COST_CHILDREN,\n        level: 0,\n        type: \"pseudo\",\n        selector: `:has(* :nth-child(${children.length}):last-child)`,\n      });\n    }\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      const localSelectors = this.localGenerator.generate([child]);\n      for (const childrenLocalSelector of localSelectors) {\n        selectors.push({\n          cost:\n            depth * COST_DISTANCE +\n            COST_IS_HAS +\n            COST_CHILDREN +\n            childrenLocalSelector.cost,\n          level: 0,\n          type: \"pseudo\",\n          selector:\n            depth > 0\n              ? `:has(${depthSelector}>${childrenLocalSelector.selector})`\n              : `:has(>${childrenLocalSelector.selector})`,\n        });\n\n        if (depth > 0) {\n          selectors.push({\n            cost:\n              COST_DISTANCE +\n              COST_IS_HAS +\n              COST_CHILDREN +\n              childrenLocalSelector.cost,\n            level: 0,\n            type: \"pseudo\",\n            selector: `:has(* ${childrenLocalSelector.selector})`,\n          });\n        }\n      }\n\n      // Recursively process descendants (go deeper, more negative level)\n      this.#processChildren(child, depth + 1, selectors);\n    }\n  }\n\n  /**\n   * Generates children selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate children selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n      this.#processChildren(element, 0, sels);\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(d => d.selector === descriptor.selector)\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_ATTR,\n  COST_CHILDREN,\n  COST_CLASS,\n  COST_IS_HAS,\n  COST_ID,\n  COST_NOT,\n} from \"../config/costs.js\";\nimport {\n  BLACKLIST_IDS,\n  BLACKLIST_CLASSES,\n  BLACKLIST_ATTRIBUTES,\n} from \"../config/constants.js\";\nimport { BlacklistMatcher } from \"../utils/BlacklistMatcher.js\";\n\n/**\n * Generates :not(:has()) pseudo-selectors to exclude elements based on other elements children\n * If elements differ only by their children, we can select them by the selectors generates by this class\n */\nexport class ChildrenExclusionGenerator {\n  /**\n   * Creates a ChildrenExclusionGenerator instance.\n   * @param {DOMService} domService - Service for DOM queries\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {SelectorBuilder} selectorBuilder - Builder for constructing selectors\n   */\n  constructor(domService, localGenerator, selectorBuilder) {\n    this.domService = domService;\n    this.localGenerator = localGenerator;\n    this.selectorBuilder = selectorBuilder;\n  }\n\n  /**\n   * Generates children exclusion selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate children exclusion selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      const elementSelector = this.localGenerator.generate([element]);\n      const childrenSelector = this.selectorBuilder.build(elementSelector) + \" *\";\n      const allChildren = this.domService.querySelectorAll(childrenSelector);\n\n      const extraClasses = [];\n      const extraAttr = [];\n\n      for (let i = 0; i < allChildren.length; i++) {\n        const currentChild = allChildren[i];\n\n        // Skip children that belong to the element itself\n        if (element.contains(currentChild)) {\n          continue;\n        }\n\n        // Collect extra id (skip if blacklisted)\n        const id = currentChild.getAttribute(\"id\");\n        if (id !== null && !BlacklistMatcher.matches(id, BLACKLIST_IDS)) {\n          sels.push({\n            cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_ID,\n            level: 0,\n            type: \"pseudo\",\n            selector: \":not(:has(#\" + CSS.escape(id) + \"))\",\n          });\n        }\n\n        // Collect extra classes (skip if blacklisted)\n        currentChild.classList.forEach((currentClass) => {\n          if (\n            !element.querySelector(\".\" + CSS.escape(currentClass)) &&\n            !extraClasses.includes(currentClass) &&\n            !BlacklistMatcher.matches(currentClass, BLACKLIST_CLASSES)\n          ) {\n            extraClasses.push(CSS.escape(currentClass));\n          }\n        });\n\n        // Collect extra attributes (skip if blacklisted)\n        const attributes = currentChild.attributes;\n        for (let j = 0; j < attributes.length; j++) {\n          const currentAttr = attributes.item(j);\n          if (\n            !element.querySelector(\"[\" + CSS.escape(currentAttr.name) + \"]\") &&\n            !extraAttr.includes(currentAttr.name) &&\n            !BlacklistMatcher.matches(currentAttr.name, BLACKLIST_ATTRIBUTES)\n          ) {\n            extraAttr.push(CSS.escape(currentAttr.name));\n          }\n        }\n      }\n\n      for (let i = 0; i < extraClasses.length; i++) {\n        sels.push({\n          cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_CLASS,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(:has(.\" + extraClasses[i] + \"))\",\n        });\n      }\n\n      for (let i = 0; i < extraAttr.length; i++) {\n        sels.push({\n          cost: COST_NOT + COST_IS_HAS + COST_CHILDREN + COST_ATTR,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":not(:has([\" + extraAttr[i] + \"]))\",\n        });\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(d => d.selector === descriptor.selector)\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport {\n  COST_DISTANCE,\n  COST_IS_HAS,\n  COST_SIBLING,\n} from \"../config/costs.js\";\n\n/**\n * Generates selectors based on sibling relationships.\n */\nexport class SiblingSelectorGenerator {\n  /**\n   * Creates a SiblingSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   */\n  constructor(localGenerator) {\n    this.localGenerator = localGenerator;\n  }\n\n  /**\n   * Generates sibling selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate sibling selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      let prevSibling = element.previousElementSibling;\n      const prevSiblingCount =\n        prevSibling !== null\n          ? Array.from(element.parentElement.children).indexOf(element)\n          : 0;\n\n      let nextSibling = element.nextElementSibling;\n      const nextSiblingCount =\n        nextSibling !== null\n          ? Array.from(element.parentElement.children).length -\n            Array.from(element.parentElement.children).indexOf(element)\n          : 0;\n\n      if (prevSibling === null) {\n        // there is no previous sibling\n        sels.push({\n          cost: (nextSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":first-child\",\n        });\n      } else {\n        // there are previous siblings\n        sels.push({\n          cost: (prevSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":nth-child(\" + (prevSiblingCount + 1) + \")\",\n        });\n      }\n\n      if (nextSibling === null) {\n        // there is no next sibling\n        sels.push({\n          cost: (prevSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":last-child\",\n        });\n      } else {\n        // there are next siblings, so we can use nth-last-child\n        // however, we will only use this if there are prev siblings too\n        // if there are not, nth-child is better\n        if (prevSiblingCount > 0) {\n          sels.push({\n            cost: (nextSiblingCount + 1) * COST_DISTANCE + COST_SIBLING,\n            level: 0,\n            type: \"pseudo\",\n            selector: \":nth-last-child(\" + nextSiblingCount + \")\",\n          });\n        }\n      }\n\n      if (prevSibling === null && nextSibling === null) {\n        sels.push({\n          cost: COST_SIBLING,\n          level: 0,\n          type: \"pseudo\",\n          selector: \":only-child\",\n        });\n      }\n\n      while (prevSibling) {\n        if (prevSibling.nodeType === Node.COMMENT_NODE) {\n          prevSibling = prevSibling.previousElementSibling;\n          continue;\n        }\n        if (prevSibling.nodeType === Node.TEXT_NODE) {\n          prevSibling = prevSibling.previousElementSibling;\n          continue;\n        }\n\n        const localSelectors = this.localGenerator.generate([prevSibling]);\n        for (const currentSelector of localSelectors) {\n          if (\n            !sels.some(\n              (s) => s.selector === \":is(\" + currentSelector.selector + \" ~ *)\"\n            )\n          ) {\n            sels.push({\n              cost: COST_SIBLING + COST_IS_HAS + currentSelector.cost,\n              level: 0,\n              type: \"pseudo\",\n              selector: \":is(\" + currentSelector.selector + \" ~ *)\",\n            });\n          }\n        }\n        prevSibling = prevSibling.previousElementSibling;\n      }\n\n      while (nextSibling) {\n        if (nextSibling.nodeType === Node.COMMENT_NODE) {\n          nextSibling = nextSibling.nextElementSibling;\n          continue;\n        }\n        if (nextSibling.nodeType === Node.TEXT_NODE) {\n          nextSibling = nextSibling.nextElementSibling;\n          continue;\n        }\n\n        const localSelectors = this.localGenerator.generate([nextSibling]);\n        for (const currentSelector of localSelectors) {\n          if (\n            !sels.some(\n              (s) => s.selector === \":has(~ \" + currentSelector.selector + \")\"\n            )\n          ) {\n            sels.push({\n              cost: COST_SIBLING + COST_IS_HAS + currentSelector.cost,\n              level: 0,\n              type: \"pseudo\",\n              selector: \":has(~ \" + currentSelector.selector + \")\",\n            });\n          }\n        }\n        nextSibling = nextSibling.nextElementSibling;\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(d => d.selector === descriptor.selector)\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from \"../validators/ElementValidator.js\";\nimport { COST_DISTANCE, COST_PARENT } from \"../config/costs.js\";\n\n/**\n * Generates selectors based on parent elements.\n */\nexport class ParentSelectorGenerator {\n  /**\n   * Creates a ParentSelectorGenerator instance.\n   * @param {LocalSelectorGenerator} localGenerator - Generator for local selectors\n   * @param {LocalExclusionGenerator} exclusionGenerator - Generator for exclusion selectors\n   * @param {SiblingSelectorGenerator} siblingGenerator - Generator for sibling selectors\n   */\n  constructor(localGenerator, exclusionGenerator, siblingGenerator) {\n    this.localGenerator = localGenerator;\n    this.exclusionGenerator = exclusionGenerator;\n    this.siblingGenerator = siblingGenerator;\n  }\n\n  /**\n   * Generates parent selectors for elements.\n   * Returns only selectors that are common to all target elements.\n   * @param {Array<HTMLElement|SVGElement>} elements - The target elements\n   * @returns {Array<SelectorDescriptor>} Array of selector descriptors\n   */\n  generate(elements) {\n    for (const element of elements) {\n      ElementValidator.assertValid(element);\n    }\n\n    const selectors = [];\n\n    // Generate parent selectors for each element\n    const elementSelectors = elements.map(element => {\n      const sels = [];\n\n      let currentParent = element.parentElement;\n      let level = 1;\n\n      while (currentParent) {\n        const localSelectors = this.localGenerator.generate([currentParent]);\n        for (const currentSelector of localSelectors) {\n          sels.push({\n            cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n            level: level,\n            type: currentSelector.type,\n            selector: currentSelector.selector,\n          });\n        }\n\n        const localExclSelectors =\n          this.exclusionGenerator.generate([currentParent]);\n        for (const currentSelector of localExclSelectors) {\n          sels.push({\n            cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n            level: level,\n            type: currentSelector.type,\n            selector: currentSelector.selector,\n          });\n        }\n\n        const siblingSelectors = this.siblingGenerator.generate([currentParent]);\n        for (const currentSelector of siblingSelectors) {\n          sels.push({\n            cost: level * COST_DISTANCE + COST_PARENT + currentSelector.cost,\n            level: level,\n            type: currentSelector.type,\n            selector: currentSelector.selector,\n          });\n        }\n\n        currentParent = currentParent.parentElement;\n        level = level + 1;\n      }\n\n      return sels;\n    });\n\n    // Find common selectors across all elements\n    if (elementSelectors.length === 0) return selectors;\n\n    const firstSet = elementSelectors[0];\n    for (const descriptor of firstSet) {\n      const isCommon = elementSelectors.every(set =>\n        set.some(d => d.selector === descriptor.selector)\n      );\n      if (isCommon) {\n        selectors.push(descriptor);\n      }\n    }\n\n    return selectors;\n  }\n}\n", "import { ElementValidator } from './validators/ElementValidator.js';\nimport { DOMService } from './services/DOMService.js';\nimport { SelectorBuilder } from './builders/SelectorBuilder.js';\nimport { BottomUpSelectorOptimizer } from './optimizers/BottomUpSelectorOptimizer.js';\nimport { TopDownSelectorOptimizer } from './optimizers/TopDownSelectorOptimizer.js';\nimport { LocalSelectorGenerator } from './generators/LocalSelectorGenerator.js';\nimport { LocalExclusionGenerator } from './generators/LocalExclusionGenerator.js';\nimport { ChildrenSelectorGenerator } from './generators/ChildrenSelectorGenerator.js';\nimport { ChildrenExclusionGenerator } from './generators/ChildrenExclusionGenerator.js';\nimport { SiblingSelectorGenerator } from './generators/SiblingSelectorGenerator.js';\nimport { ParentSelectorGenerator } from './generators/ParentSelectorGenerator.js';\n\n/**\n * Main class for generating optimal CSS selectors for DOM elements.\n */\nexport class SelectorGenerator {\n  constructor() {\n    // Initialize services\n    this.domService = new DOMService();\n    this.selectorBuilder = new SelectorBuilder();\n    this.bottomUpOptimizer = new BottomUpSelectorOptimizer(this.domService, this.selectorBuilder);\n    this.topDownOptimizer = new TopDownSelectorOptimizer(this.domService, this.selectorBuilder);\n\n    // Initialize generators\n    this.localGenerator = new LocalSelectorGenerator();\n    this.exclusionGenerator = new LocalExclusionGenerator(\n      this.domService,\n      this.localGenerator,\n      this.selectorBuilder\n    );\n    this.childrenGenerator = new ChildrenSelectorGenerator(this.localGenerator);\n    this.childrenExclusionGenerator = new ChildrenExclusionGenerator(\n      this.domService,\n      this.localGenerator,\n      this.selectorBuilder\n    );\n    this.siblingGenerator = new SiblingSelectorGenerator(this.localGenerator);\n    this.parentGenerator = new ParentSelectorGenerator(\n      this.localGenerator,\n      this.exclusionGenerator,\n      this.siblingGenerator\n    );\n  }\n\n  /**\n   * Generates an optimal CSS selector for the given element(s).\n   * For a single element, generates a unique selector matching only that element.\n   * For multiple elements, generates a selector matching all of them (and only them).\n   * @param {HTMLElement|SVGElement|Array<HTMLElement|SVGElement>} elements - The target element(s)\n   * @returns {string} CSS selector string that uniquely identifies the element(s)\n   * @throws {Error} If elements don't share the same parent or invalid element type\n   */\n  getSelector(elements) {\n    // Handle both single element and array of elements\n    const normalizedElements = Array.isArray(elements) ? elements : [elements];\n\n    // Validate all elements\n    for (const element of normalizedElements) {\n      ElementValidator.assertValid(element);\n    }\n\n    // For multiple elements, verify they share the same parent\n    if (normalizedElements.length > 1) {\n      const firstParent = normalizedElements[0].parentElement;\n      for (let i = 1; i < normalizedElements.length; i++) {\n        const currentParent = normalizedElements[i].parentElement;\n        const parentsEqual = currentParent === firstParent;\n\n        console.log(`[DEBUG] Element ${i} check:`, {\n          currentElement: normalizedElements[i],\n          currentParent: currentParent,\n          firstParent: firstParent,\n          areEqual: parentsEqual,\n          currentParentTagName: currentParent?.tagName,\n          firstParentTagName: firstParent?.tagName,\n        });\n\n        if (!parentsEqual) {\n          throw new Error(\n            `All elements must share the same parent for multi-element selector generation (element ${i} differs)`\n          );\n        }\n      }\n    }\n\n    let selectors = [];\n\n    selectors = selectors.concat(this.localGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.exclusionGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.childrenGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.siblingGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.parentGenerator.generate(normalizedElements));\n    selectors = selectors.concat(this.childrenExclusionGenerator.generate(normalizedElements));\n\n    /*\n    // Try bottom-up optimization first (fast, works for most cases)\n    let bestSelectorSet = this.bottomUpOptimizer.findBest(normalizedElements, selectors);\n    let value = this.bottomUpOptimizer.getValue(normalizedElements, bestSelectorSet);\n\n    // If bottom-up didn't find a unique selector, try top-down\n    if (value !== normalizedElements.length) {\n      bestSelectorSet = this.topDownOptimizer.findBest(normalizedElements, selectors);\n    }\n    */\n\n    let bestSelectorSet = this.topDownOptimizer.findBest(normalizedElements, selectors);\n\n    const selector = this.selectorBuilder.build(bestSelectorSet);\n\n    return selector;\n  }\n}\n", "/**\n * Public API for the Selector Generator library.\n * Provides an IIFE wrapper for backward compatibility with the original implementation.\n */\nimport { SelectorGenerator as SelectorGeneratorClass } from './SelectorGenerator.js';\n\n// Create the wrapped API (same interface as the original)\nconst SelectorGenerator = (function() {\n  'use strict';\n\n  const generator = new SelectorGeneratorClass();\n\n  return {\n    getSelector: (elements) => generator.getSelector(elements)\n  };\n})();\n\n// Set as global for backward compatibility (if in browser)\nif (typeof window !== 'undefined') {\n  window.SelectorGenerator = SelectorGenerator;\n}\n\n// Export for module systems (ESM builds only)\nexport { SelectorGenerator };\nexport { SelectorGeneratorClass };\n"],
  "mappings": "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",
  "names": ["ElementValidator", "element", "DOMService", "selector", "_simpleBuild", "simpleBuild_fn", "SelectorBuilder", "__privateAdd", "selectorSet", "tagSelectors", "x", "idSelectors", "classSelectors", "attrSelectors", "pseudoSelectors", "parentSelectors", "selector", "levelMap", "ps", "levels", "b", "prevLevel", "level", "levelSelector", "__privateMethod", "selectors", "BottomUpSelectorOptimizer", "domService", "selectorBuilder", "elements", "selectorSet", "selector", "results", "count", "resultsArray", "element", "selectors", "a", "b", "bestSelectorSet", "bestValue", "targetCount", "threshold", "improving", "localBestSelectorSet", "localBestValue", "trialSelectorSet", "trialValue", "currentSelector", "DebugOptimizer", "domService", "selectorBuilder", "element", "selectorSet", "selector", "results", "selectors", "result", "trialSet", "_", "index", "TopDownSelectorOptimizer", "domService", "selectorBuilder", "DebugOptimizer", "elements", "selectorSet", "selector", "results", "count", "resultsArray", "element", "cost", "sum", "descriptor", "selectors", "currentSet", "currentValue", "targetCount", "minimalNonMatching", "sortedSelectors", "a", "b", "improved", "selectorToRemove", "trialSet", "s", "trialValue", "BLACKLIST_IDS", "BLACKLIST_CLASSES", "BLACKLIST_ATTRIBUTES", "_patternToRegex", "patternToRegex_fn", "BlacklistMatcher", "value", "patterns", "pattern", "__privateMethod", "values", "regexPattern", "__privateAdd", "LocalSelectorGenerator", "elements", "element", "ElementValidator", "selectors", "elementSelectors", "sels", "BlacklistMatcher", "BLACKLIST_IDS", "i", "attributes", "name", "currentClass", "BLACKLIST_CLASSES", "BLACKLIST_ATTRIBUTES", "firstSet", "descriptor", "set", "d", "AttributeCollector", "targetElement", "elements", "extraIds", "i", "currentElement", "id", "BlacklistMatcher", "BLACKLIST_IDS", "extraClasses", "currentClass", "BLACKLIST_CLASSES", "extraAttr", "attributes", "j", "currentAttr", "BLACKLIST_ATTRIBUTES", "LocalExclusionGenerator", "domService", "localGenerator", "selectorBuilder", "elements", "element", "ElementValidator", "selectors", "elementExclusions", "localSelectors", "baseSelector", "matchedElements", "exclSelectors", "collector", "AttributeCollector", "extraIds", "extraClasses", "extraAttributes", "i", "firstSet", "descriptor", "set", "d", "_processChildren", "processChildren_fn", "ChildrenSelectorGenerator", "localGenerator", "__privateAdd", "elements", "element", "ElementValidator", "selectors", "elementSelectors", "sels", "__privateMethod", "firstSet", "descriptor", "set", "d", "depth", "children", "depthSelector", "i", "child", "localSelectors", "childrenLocalSelector", "ChildrenExclusionGenerator", "domService", "localGenerator", "selectorBuilder", "elements", "element", "ElementValidator", "selectors", "elementSelectors", "sels", "elementSelector", "childrenSelector", "allChildren", "extraClasses", "extraAttr", "i", "currentChild", "id", "BlacklistMatcher", "BLACKLIST_IDS", "currentClass", "BLACKLIST_CLASSES", "attributes", "j", "currentAttr", "BLACKLIST_ATTRIBUTES", "firstSet", "descriptor", "set", "d", "SiblingSelectorGenerator", "localGenerator", "elements", "element", "ElementValidator", "selectors", "elementSelectors", "sels", "prevSibling", "prevSiblingCount", "nextSibling", "nextSiblingCount", "localSelectors", "currentSelector", "s", "firstSet", "descriptor", "set", "d", "ParentSelectorGenerator", "localGenerator", "exclusionGenerator", "siblingGenerator", "elements", "element", "ElementValidator", "selectors", "elementSelectors", "sels", "currentParent", "level", "localSelectors", "currentSelector", "localExclSelectors", "siblingSelectors", "firstSet", "descriptor", "set", "d", "SelectorGenerator", "DOMService", "SelectorBuilder", "BottomUpSelectorOptimizer", "TopDownSelectorOptimizer", "LocalSelectorGenerator", "LocalExclusionGenerator", "ChildrenSelectorGenerator", "ChildrenExclusionGenerator", "SiblingSelectorGenerator", "ParentSelectorGenerator", "elements", "normalizedElements", "element", "ElementValidator", "firstParent", "i", "currentParent", "parentsEqual", "selectors", "bestSelectorSet", "SelectorGenerator", "generator", "elements"]
}
